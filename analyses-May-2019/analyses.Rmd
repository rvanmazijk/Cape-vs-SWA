---
title: "Analyses v2"
subtitle: "Cape vs SWA"
author: "Ruan van Mazijk"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
library(here)
source(here("analyses-May-2019/setup.R"))
```

# Preamble/outline

Here I layout the "new", second incarnation of the analyses as discussed over the course of May/June 2019, following the first draft of the manuscript.

To reiterate that manuscript, we hypothesise that the greater vascular plant species richness of the GCFR compared to that of the SWAFR is explained by the regions' difference in environmental heterogeneity.

The proposed "story" of questions for the analyses is as follows:

1. Is the GCFR more heterogeneous environmentally than the SWAFR, and does the scale of that heterogeneity differ to that of the SWAFR?
2. Do the regions differ w.r.t. the species richness of both HDS and QDS cells, and, for HDS cells' richness ($S_{HDS}$), does the explanatory power of mean QDS richness ($S_{QDS}$) and turnover ($T_{QDS}$) differ between the regions?
3. Does heterogeneity explain differences in richness and turnover between the regions?

# 1. Environmental heterogeneity & scale

Is the GCFR more heterogeneous environmentally than the SWAFR, and does the scale of that heterogeneity differ to that of the SWAFR?

In order to determine which region is more environmentally heterogeneous, and what scales heterogeneity is most pronounced, we calculated a measure of environmental heterogeneity at various spatial scales (namely: the base data resolution (0.05ยบ x 0.05ยบ), eighth- (EDS), quarter- (QDS), half- (HDS) and three-quarter-degree-squares (3QDS)).

Environmental "roughness" in both regions was calculated, in moving 3 x 3 cell windows, as the average absolute difference between cells and their (usually) 8 neighbours. Alternatively, for a focal cell $x^*$, the roughness is based on $x_1, x_2, \dots, x_i, \dots, x_8$ neighbour cells as:

\begin{align*}
  Roughness(x^*) =
    f \left( \begin{matrix}
      x_1 & x_2 & x_3 \\
      x_4 & x^* & x_5 \\
      x_6 & x_7 & x_8
    \end{matrix} \right) =
    \frac{1}{n} \sum_{i=1}^n |x^* - x_i|
\end{align*}

In R, this is implemented this as follows:

```{r print-roughness-body, echo=TRUE, eval=FALSE}
roughness <- function(x) {
  raster::focal(x, matrix(1, nrow = 3, ncol = 3), function(x) {
    focal_cell <- x[5]
    focal_exists <- (!is.na(focal_cell)) & (!is.nan(focal_cell))
    if (focal_exists) {
      neighbour_exists <- (!is.na(x)) & (!is.nan(x)) & (x != focal_cell)
      neighbour_cells <- x[neighbour_exists]
      return(mean(abs(focal_cell - neighbour_cells)))
    } else {
      return(NA)
    }
  })
}
```

Following this, the various forms environmental heterogeneity were ordinated using principal component analysis (PCA), to summarise a major axis of heterogeneity in each region (Figure 1). Portions of the data matrices for each scale for these PCAs are shown in Table 1.

Both the actual environmental heterogeneity values and the principal component of heterogeneity were then compared between the GCFR and SWAFR using common language effect sizes ($CLES$). The $CLES$ of GCFR vs SWAFR heterogeneity values was regressed against the spatial scale at which it was calculated using simple linear regression (Figure 2, Table 2).

We can see that PDQ, NDVI, pH and, arguably, elevation are all consistently more heterogeneous in the GCFR than in the SWAFR, regardless of spatial scale (Figure 2). The GCFR is more heterogeneous at finer scales in terms of MAP, surface temperature, CEC and soil carbon (Figure 2). Notably, the GCFR is more pronouncedly heterogeneous at broad scales in terms of clay (Figure 2). In general (i.e. regarding PC1; Figure 2), the GCFR is more environmentally heterogeneous than the SWAFR, and particularly so at fine spatial scales.

```{r import-roughness-matrices, include=FALSE}
output_path      <- here("outputs/roughness")
resolutions      <- c("base", "EDS", "QDS", "HDS", "3QDS")
matrix_filenames <- glue("{output_path}/{resolutions}_roughness_matrix.csv")

roughness_matrices <- map(matrix_filenames, read_csv)
names(roughness_matrices) <- resolutions
```

```{r print-roughness-matrix-example}
roughness_matrices %$%
  base %>%
  mutate_if(is.numeric, log1p) %>%
  mutate_if(is.numeric, round, digits = 2) %>%
  {rbind(.[1:3, ], rep("...", 11), tail(.)[1:3, ])} %>%
  knitr::kable(caption = paste(
    "Portions of the data matrices used in the PCA for this",
    "section of the analysis, where roughness values were",
    "$log(x + 1)$-transformed to ensure normality."
  ))
```

```{r PCA-analysis, include=FALSE}
roughness_PCAs <- map(roughness_matrices,
  ~ .x[, -1] %>%
    log1p() %>%
    prcomp(scale. = TRUE)
)

# Force PC1 scores to be positive if all vars rotations are negative
roughness_PCAs %<>% map(function(PCA) {
  if (all(PCA$rotation[, 1] <= 0)) {
    PCA$rotation[, 1] %<>% multiply_by(-1)
    PCA$x[, 1]        %<>% multiply_by(-1)
  }
  PCA
})

# Store PC1 & 2 in matrices for later
roughness_matrices <- map2(roughness_PCAs, roughness_matrices,
  function(PCA, layer) {
    layer$PC1 <- PCA$x[, 1]
    layer$PC2 <- PCA$x[, 2]
    layer
  }
)
```

```{r plot-PCA, fig.height=8, fig.cap="Scatter plots of the first and second principal components (PC1, PC2) of environmental heterogeneity following principal components analyses (PCAs) of the various forms of environmental heterogeneity, repeated at the five spatial scales. The proportion of variation accounted for by each axis is denoted in parentheses. Arrows (labelled) denote the rotational loading of a given form of environmental heterogeneity. Note, the signs of loadings on PC1 have been forced to be positive, while the signs of loadings on PC2 are arbitrary."}
roughness_PCA_plots <- map2(roughness_PCAs, roughness_matrices,
  ~ autoplot(.x,
      data = .y, colour = "region", alpha = 0.25,
      loadings = TRUE, loadings.colour = "black",
      loadings.label = TRUE, loadings.label.colour = "black",
      loadings.label.hjust = -0.25
    ) +
    geom_hline(yintercept = 0, lty = "dashed", alpha = 0.5) +
    geom_vline(xintercept = 0, lty = "dashed", alpha = 0.5)
)
# Get legend to use as panel
my_legend <- get_legend(roughness_PCA_plots[[1]])
# Remove legends from PCA plots themselves
roughness_PCA_plots %<>% map(~.x + theme(legend.position = "none"))
# Store panels in list
roughness_PCA_plots <- c(roughness_PCA_plots, my_legend = list(my_legend))
# Plot panels
plot_grid(
  plotlist = roughness_PCA_plots,
  labels   = c("0.05ยบ", "EDS", "QDS", "HDS", "3QDS", ""),
  nrow     = 3
)
```

```{r map-PCA}
# TODO: Plot maps of exemplary roughness variables and PC1
```

```{r CLES-analysis, include=FALSE}
GCFR_roughness_data <- roughness_matrices %>%
  map(filter, region == "GCFR") %>%
  map(dplyr::select, -region, -PC2)
SWAFR_roughness_data <- roughness_matrices %>%
  map(filter, region == "SWAFR") %>%
  map(dplyr::select, -region, -PC2)

# (WARNING: this takes a while... Only run if haven't already...)
if (!file.exists(glue("{output_path}/CLES_results.csv"))) {
  set.seed(1234)
  CLES_results <- map2_df(GCFR_roughness_data, SWAFR_roughness_data,
    .id = "resolution",  # for every spatial resolution,
    ~ map2_df(.x, .y,
      .id = "variable",  # for every variable in each region,
      ~tibble(CLES_value = CLES(.y, .x))
    )
  )
  # Save results to disc
  write_csv(
    CLES_results,
    glue("{output_path}/CLES_results.csv")
  )
} else {  # (... Or import from disc.)
  CLES_results <- read_csv(glue("{output_path}/CLES_results.csv"))
}

# Tidy
CLES_results %<>%
  filter(variable != "region", variable != "PC2") %>%
  mutate(resolution = case_when(
    resolution == "base" ~ 0.05,
    resolution == "EDS"  ~ 0.125,
    resolution == "QDS"  ~ 0.25,
    resolution == "HDS"  ~ 0.50,
    resolution == "3QDS" ~ 0.75
  )) %>%
  mutate(variable_type = case_when(
    variable == "PC1"                          ~ "PC1",
    variable == "Elevation"                    ~ "Elevation",
    variable == "NDVI"                         ~ "NDVI",
    variable %in% c("MAP", "PDQ", "Surface.T") ~ "Climate",
    TRUE                                       ~ "Soil"
  )) %>%
  mutate(variable_type = factor(variable_type, levels = c(
    "Elevation",
    "Climate",
    "NDVI",
    "Soil",
    "PC1"
  ))) %>%
  mutate(variable = factor(variable, levels = c(
    "Elevation",
    "MAP", "PDQ", "Surface.T",
    "NDVI",
    "CEC", "Clay", "Soil.C", "pH",
    "PC1"
  )))
```

```{r model-CLES}
# Fit linear models of CLES ~ spatial scale for each variable
CLES_models <- CLES_results %>%
  split(.$variable) %>%
  map(~lm(CLES_value ~ resolution, .x))
# Summarise those models
CLES_model_summaries <- CLES_models %>%
  map_df(.id = "variable", tidy) %>%
  filter(term != "(Intercept)") %>% 
  mutate(sig = case_when(
    p.value <= 0.05 ~ "*",
    p.value <= 0.10 ~ ".",
    TRUE            ~ " "
  )) %>%
  mutate(variable = factor(variable, levels = var_names %>%
    str_replace_all(" ", ".") %>%
    c("PC1")
  )) %>%
  mutate_if(is.numeric, round, digits = 3) %>%
  dplyr::select(variable, estimate, p.value, sig)
# Print table
knitr::kable(CLES_model_summaries,
  caption = paste(
    "Slopes and associated $P$-values from simple linear regressions",
    "of $CLES$ against scale for each form of environmental roughness",
    "(Figure 2)."
  ),
  col.names = c("Variable", "Slope", "$P$", " "),
  align = "lrrc"
)
```

```{r test-CLES-against-zero, include=FALSE}
# Also show how I tested for CLES different to zero
CLES_results %>%
  split(.$variable) %>%
  map(pull, CLES_value) %>%
  map(t.test) %>%
  map_df(.id = "variable", tidy) %>%
  dplyr::select(variable, p.value) %>%
  mutate(sig = p.value < 0.001)
```

```{r plot-CLES-fits, fig.cap="Regressions of the common language effect size ($CLES$) of various forms of environmental heterogeneity, and the first principal component thereof (PC1, see Figure 1). Only significant or marginally significant fits are plotted (Table 2). Across spatial scales, all $CLES$ values differed significantly from zero following a two-side $t$-test ($P < 0.001$), demonstrating the difference in heterogeneity between the regions."}
# Create empty panels
empty_plots <- ggplot(CLES_results, aes(resolution, CLES_value)) +
  geom_hline(yintercept = 0.5, lty = "dashed") +
  facet_wrap(~variable, nrow = 2) +
  scale_x_continuous(
    name   = "Scale",
    breaks = c(0.05,   0.125, 0.25,  0.50,  0.75),
    labels = c("0.05ยบ", "EDS", "QDS", "HDS", "3QDS")
  ) +
  scale_y_continuous(
    name   = "CLES\n(GCFR > SWAFR)",
    breaks = c(0.50, 0.75, 1.00)      
  ) +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 90)
  )
# Create dataset without data for NS regressions (above),
# so that geom_smooth() can't plot for those variables
CLES_results_sans_NS <- mutate(CLES_results,
  CLES_value = ifelse(variable %in% c("NDVI", "PDQ", "pH"),
    NA,
    CLES_value
  )
)
# Add fits to empty plots
CLES_plots <- empty_plots +
  geom_smooth(
    data    = CLES_results_sans_NS,
    mapping = aes(group = variable),
    method  = lm,
    colour  = "grey25"
  ) +
  # Plot full dataset on top of fits for clarity
  geom_point(data = CLES_results)

CLES_plots
```

\clearpage

# 2. Species richness & turnover

Do the regions differ w.r.t. the species richness of both HDS and QDS cells, and, for HDS cells' richness ($S_{HDS}$), does the explanatory power of mean QDS richness ($S_{QDS}$) and turnover ($T_{QDS}$) differ between the regions?

To tackle this question, I compare measures of species richness and turnover between the regions. Species richness at the HDS-scale ($S_{\mathrm{HDS}}$) can be partitioned into the average richness of the constituent QDS in HDS ($\overline{S}_{\mathrm{QDS}}$) and species turnover ($T_{\mathrm{QDS}}$) defined^[following Whittaker's original additive definition: $\gamma = \alpha + \beta$] as:

$$
  T_{\mathrm{QDS}} = S_{\mathrm{HDS}} - \overline{S}_{\mathrm{QDS}}
$$

The distributions of these data are presented in Figure 3. To test for significant differences between GCFR and SWAFR values, I use Mann-Whitney $U$-tests and $CLES$ (Table 3), as most of the variables deviate significantly from normality (Shapiro-Wilk normality test; $P < 0.05$).

Additionally, a visualisation of how $S_{\mathrm{HDS}}$ is partitioned into $\overline{S}_{\mathrm{QDS}}$ and $T_{\mathrm{QDS}}$ is presented in Figure 4.

We can conclude that broad scale species richness (i.e. that at the HDS scale) is more strongly driven by turnover between areas (i.e. QDS) than so in the SWAFR.

```{r import-cellular-data, include=FALSE}
HDS <- read_csv(here("outputs/QDS_data_cells.csv"))
QDS <- read_csv(here("outputs/EDS_data_cells.csv"))
HDS_QDS <- as_tibble(rbind(
  HDS %>%
    dplyr::select(region, HDS_richness, add_turnover_prop) %>%
    gather(metric, value, HDS_richness, add_turnover_prop),
  QDS %>%
    dplyr::select(region, QDS_richness) %>%
    gather(metric, value, QDS_richness)
))
```

```{r test-richness-turnover-univariate}
HDS_QDS %>%
  mutate(metric = case_when(
    metric == "HDS_richness"      ~ "$S_{\\mathrm{HDS}}$",
    metric == "QDS_richness"      ~ "$S_{\\mathrm{QDS}}$",
    metric == "add_turnover_prop" ~ "$T_{\\mathrm{QDS}} / S_{\\mathrm{HDS}}$"
  )) %>%
  mutate(metric = factor(metric, levels = c(
    "$S_{\\mathrm{HDS}}$",
    "$S_{\\mathrm{QDS}}$",
    "$T_{\\mathrm{QDS}} / S_{\\mathrm{HDS}}$"
  ))) %>%
  group_by(metric) %>%
  summarise(
    P = wilcox.test(value[region == "SWAFR"], value[region == "GCFR"])$p.value,
    CLES_value = CLES(value[region == "SWAFR"], value[region == "GCFR"])
  ) %>%
  mutate_if(is.numeric, ~ifelse(.x < 0.001,
    "$< 0.001$",
    format(round(.x, digits = 3), nsmall = 3)
  )) %>%
  dplyr::select(metric, CLES_value, P) %>%
  knitr::kable(
    caption = paste(
      "Results of Mann-Whitney $U$-tests and the $CLES$ of GCFR vs SWAFR",
      "for various species richness and turnover metrics."
    ),
    col.names = c("Metric", "$CLES$", "$P_U$"),
    align = "lrr"
  )
```

```{r test-richness-turnover-normality, include=FALSE}
# Also show how I tested for metrics deviating from normality
HDS_QDS %>%
  group_by(metric) %>%
  summarise(
    P_GCFR  = shapiro.test(value[region == "GCFR"])$p.value,
    P_SWAFR = shapiro.test(value[region == "SWAFR"])$p.value
  ) %>%
  mutate_at(c("P_GCFR", "P_SWAFR"), list(sig = ~ . < 0.05))
```

```{r visualise-partitions, fig.width=9, fig.height=3, fig.cap="Scatter plot of $\\overline{S}_{\\mathrm{QDS}}$ and $T_{\\mathrm{QDS}}$ with contour lines denoting the $S_{\\mathrm{HDS}}$ that would arise as their sum (i.e. increasing from lower-left to upper-right)."}
hist_plots <- HDS_QDS %>%
  filter(metric %in% c("HDS_richness", "add_turnover_prop")) %>%
  mutate(metric = case_when(
    metric == "HDS_richness"      ~ "italic(S)[HDS]",
    metric == "add_turnover_prop" ~ "italic(T)[QDS]/italic(S)[HDS]"
  )) %>%
  mutate(metric = factor(metric, levels = c(
    "italic(S)[HDS]",
    "italic(T)[QDS]/italic(S)[HDS]"
  ))) %>%
  ggplot(aes(value, fill = region)) +
    geom_histogram(bins = 20, position = "dodge", colour = "black") +
    scale_fill_manual(name = "Region", values = c("black", "white")) +
    labs(
      # Cheat-x-axis-labels
      x = bquote(
        italic("S")["HDS"]
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  # 50 spaces
        italic("T")["QDS"]/italic("S")["HDS"]
      ),
      y = "No. HDS"
    ) +
    facet_grid(~metric, scales = "free_x", labeller = label_parsed) +
    theme(axis.text.y = element_text(angle = 90), strip.text = element_blank())

plot_edges <- HDS %$%
  ceiling(max(c(mean_QDS_richness, add_turnover))) + 10

S_HDS_background <- plot_edges %>%
  {seq(from = 0, to = ., by = 10)} %>%
  {expand.grid(x = ., y = .)} %>%
  mutate(z = x + y)
S_HDS_background_plot <- ggplot(S_HDS_background) +
  lims(x = c(0, plot_edges), y = c(0, plot_edges)) +
  geom_contour(
    mapping     = aes(x, y, z = z),
    binwidth    = 500,
    colour      = "grey90",
    show.legend = TRUE
  ) +
  geom_abline(
    intercept = 0, slope = 1,
    linetype = "dashed", colour = "grey25"
  ) +
  labs(
    x = bquote(italic("T")["QDS"]),
    y = bquote(bar(italic("S"))["QDS"])
  ) +
  theme(
    legend.position = "none",
    axis.text.y     = element_text(angle = 90)
  )

partition_plot <- S_HDS_background_plot +
  geom_point(
    data    = HDS,
    mapping = aes(add_turnover, mean_QDS_richness, fill = region),
    shape   = 21
  ) +
  scale_fill_manual(name = "Region", values = c("black", "white"))

# Add labels to S_HDS contours manually
partition_plot <- partition_plot + geom_text(
  data = tibble(
    add_turnover      = c( 10,   10,   10,  360,  860, 1360),
    mean_QDS_richness = c(500, 1000, 1500, 1650, 1650, 1650),
    HDS_richness      = c(500, 1000, 1500, 2000, 2500, 3000)
  ),
  mapping = aes(add_turnover, mean_QDS_richness, label = HDS_richness),
  angle = -45, vjust = -0.5, colour = "grey50", size = 2.5
)

# Plot panels
plot_grid(
  # Flip partition plot to get axes to line up across panels (b/o text heights)
  partition_plot + coord_flip(),
  hist_plots,
  nrow = 1,
  rel_widths = c(1, 2)
)

```

\clearpage

# 3. Relating heterogeneity to species richness & turnover

Does heterogeneity explain differences in richness and turnover between the regions?

Here I fit various linear regressions of richness and turnover as functions of environmental heterogeneity.

The richness and turnover measures used are the same as in the previous section, while ...

\begin{align*}
  X      & = \{ x_1, x_2, x_3, x_4 \} \\
  R(X)   & = \frac{1}{n} \sum_{i=1}^n D(x_i) \\
  D(x_i) & = \frac{1}{m} \sum_{j=1}^m |x_i - y_j| \\
  Y      & = X \setminus x_i \\
  n      & = 4 \\
  m      & = n - 1
\end{align*}

```{r, eval=FALSE}
roughness_cells <- function(x) {
  out <- vector(length = length(x))
  for (i in seq_along(x)) {
    out[[i]] <- mean(abs(x[i] - x[-i]))
  }
  mean(out)
}
```

[Interpretations to follow after meeting.]

```{r tidy-cellular-data, include=FALSE}
# log(x + 1) & scale roughness values to match PCAs were done on logged data
HDS[, str_which(names(HDS), "roughness")] %<>%
  log1p() %>%
  scale()
QDS[, str_which(names(QDS), "roughness")] %<>%
  log1p() %>%
  scale()

GCFR_HDS <- filter(HDS, region == "GCFR")
GCFR_QDS <- filter(QDS, region == "GCFR")

SWAFR_HDS <- filter(HDS, region == "SWAFR")
SWAFR_QDS <- filter(QDS, region == "SWAFR")

predictor_names <- HDS %>%
  {names(.)[str_which(names(.), "roughness")]} %>%
  paste(collapse = " + ")
```

```{r explore-normality, include=FALSE}
## Explore normality of data
#
#non_normal_vars <- HDS[, str_which(names(HDS), "(region|mean_value)")] %>%
#  split(.$region) %>%
#  map(dplyr::select, -region) %>%
#  map(map, shapiro.test) %>%
#  map(map_df, tidy, .id = "variable") %>%
#  bind_rows(.id = "region") %>%
#  as_tibble() %>%
#  dplyr::select(-statistic, -method) %>%
#  mutate(sig = p.value <= 0.05) %>%
#  filter(sig)
#
#HDS[, str_which(names(HDS), "(region|mean_value)")] %>%
#  split(.$region) %>%
#  map(dplyr::select, -region) %>%
#  map(map, log) %>%  # !!!
#  map(map, shapiro.test) %>%
#  map(map_df, tidy, .id = "variable") %>%
#  bind_rows(.id = "region") %>%
#  as_tibble() %>%
#  dplyr::select(-statistic, -method) %>%
#  mutate(sig = p.value <= 0.05) %>%
#  filter(sig)
#
## Conclusion: Logging can't solve everything!
```

## 3.1. Separate-regions models with combinations of variables

```{r}
models <- list(
GCFR_HDS_richness = lm(glue("HDS_richness ~ {predictor_names}"),      GCFR_HDS),
GCFR_QDS_richness = lm(glue("QDS_richness ~ {predictor_names}"),      GCFR_QDS),
GCFR_QDS_turnover = lm(glue("add_turnover_prop ~ {predictor_names}"), GCFR_HDS),
SWAFR_HDS_richness= lm(glue("HDS_richness ~ {predictor_names}"),     SWAFR_HDS),
SWAFR_QDS_richness= lm(glue("QDS_richness ~ {predictor_names}"),     SWAFR_QDS),
SWAFR_QDS_turnover= lm(glue("add_turnover_prop ~ {predictor_names}"),SWAFR_HDS)
)
models %>% 
  map(step, trace = 0) %>%
  map_df(tidy, .id = "response") %>%
  dplyr::select(-std.error, -statistic) %>%
  filter(term != "(Intercept)") %>%
  mutate(
    response = case_when(
      response == "GCFR_HDS_richness"  ~ "GCFR $S_{\\mathrm{HDS}}$",
      response == "GCFR_QDS_richness"  ~ "GCFR $\\overline{S}_{\\mathrm{QDS}}$",
      response == "GCFR_QDS_turnover"  ~ "GCFR $T_{\\mathrm{QDS}}$",
      response == "SWAFR_HDS_richness" ~"SWAFR $S_{\\mathrm{HDS}}$",
      response == "SWAFR_QDS_richness" ~"SWAFR $\\overline{S}_{\\mathrm{QDS}}$",
      response == "SWAFR_QDS_turnover" ~"SWAFR $T_{\\mathrm{QDS}}$"
    ),
    term = str_remove_all(term, "_roughness"),
    sig = ifelse(p.value <= 0.05,
      "*",
      ifelse(p.value <= 0.10,
        ".",
        ""
      )
    )
  ) %>%
  mutate_if(is.numeric, ~format(round(.x, digits = 3), nsmall = 3)) %>%
  knitr::kable(
    caption = paste(
      "Results of bi-directional stepwise multiple linear regressions of",
      "three richness and turnover responses in the against additive",
      "combinations of environmental heterogeneity variables. The stepwise",
      "regression procedure started with all variables included.",
      "(See Figure 5 for a graphical representation.)"
    ),
    col.names = c("Response", "Predictor", "Slope", "$P_{slope}$", ""),
    align = "llrrc"
  )
```

```{r}
models %>% 
  map(step, trace = 0) %>%
  map_df(.id = "response", glance) %>%
  mutate(response = case_when(
    response == "GCFR_HDS_richness"  ~ "GCFR $S_{\\mathrm{HDS}}$",
    response == "GCFR_QDS_richness"  ~ "GCFR $\\overline{S}_{\\mathrm{QDS}}$",
    response == "GCFR_QDS_turnover"  ~ "GCFR $T_{\\mathrm{QDS}}$",
    response == "SWAFR_HDS_richness" ~"SWAFR $S_{\\mathrm{HDS}}$",
    response == "SWAFR_QDS_richness" ~"SWAFR $\\overline{S}_{\\mathrm{QDS}}$",
    response == "SWAFR_QDS_turnover" ~"SWAFR $T_{\\mathrm{QDS}}$"
  )) %>%
  dplyr::select(response, adj.r.squared) %>%
  mutate(adj.r.squared =
    format(round(adj.r.squared, digits = 3), nsmall = 3)
  ) %>%
  knitr::kable(
    caption = "Adjusted $R^2$-values of the models in Table 5.",
    col.names = c("Response", "${R^2}_{adj.}$")
  )
```

```{r, fig.cap="Slopes from Table 5, with error bars denoting 95% confidence intervals about each slope estimate."}
models %>% 
  map(step, trace = 0) %>%
  map_df(.id = "response", tidy, conf.int = TRUE) %>%
  dplyr::select(-std.error, -statistic, -p.value) %>%
  filter(term != "(Intercept)") %>%
  mutate(term = str_remove_all(term, "_roughness")) %>%
  separate(response, into = c("region", "scale", "response")) %>%
  unite(response, scale, response, remove = TRUE) %>%
  mutate(response = case_when(
    response == "HDS_richness" ~ "italic(S)[HDS]",
    response == "QDS_richness" ~ "italic(S)[QDS]",
    response == "QDS_turnover" ~ "italic(T)[QDS]"
  )) %>%
  ggplot(aes(term, estimate, colour = region, group = region)) +
    geom_hline(yintercept = 0, linetype = "dashed", colour = "grey25") +
    geom_point(position = position_dodge(width = 0.5)) +
    geom_errorbar(
      aes(ymin = conf.low, ymax = conf.high),
      width = 0,
      position = position_dodge(width = 0.5)
    ) +
    labs(x = "Predictor", y = "Slope") +
    scale_colour_manual(name = "Region", values = my_palette) +
    facet_grid(response ~ ., scales = "free_y", labeller = label_parsed) +
    theme(
      axis.text.x        = element_text(angle = 90),
      strip.text.y       = element_text(angle = 0),
      panel.grid.major.y = element_line(colour = "grey"),
    )
```

\clearpage

## 3.2. Combined-regions models with individual variables

### 3.2.1. Environmental heterogeneity variables

[Plots of the models referred to in Tables 6--8 can be discussed in a meeting.]

```{r, include=FALSE}
predictor_names <- names(HDS)[
  str_which(names(HDS), "roughness")
]

HDS_richness_models_no_region <- predictor_names %>%
  map(~lm(glue("HDS_richness ~ {.x}"), HDS)) %>%
  set_names(predictor_names) %>%
  {tibble(predictor = names(.), model = .)} %>%
  mutate(
    slope_p_value = map_dbl(model, ~tidy(.x)$p.value[[2]]),
    r_squared     = map_dbl(model, ~glance(.x)$r.squared),
    slope_sig     = ifelse(slope_p_value <= 0.05, "*", ""),
    plot          = map(model, visreg::visreg, gg = TRUE)
  )
HDS_richness_models_add_region <- predictor_names %>%
  map(~lm(glue("HDS_richness ~ {.x} + region"), HDS)) %>%
  set_names(predictor_names) %>%
  {tibble(predictor = names(.), model = .)} %>%
  mutate(
    slope_p_value  = map_dbl(model, ~tidy(.x)$p.value[[2]]),
    region_p_value = map_dbl(model, ~tidy(.x)$p.value[[3]]),
    r_squared      = map_dbl(model, ~glance(.x)$r.squared),
    slope_sig      = ifelse(slope_p_value  <= 0.05, "*", ""),
    region_sig     = ifelse(region_p_value <= 0.05, "*", ""),
    plot = map2(model, predictor,
      ~ visreg::visreg(.x,
        xvar    = .y,
        by      = "region",
        overlay = TRUE,
        gg      = TRUE
      )
    )
  )
HDS_richness_models_int_region <- predictor_names %>%
  map(~lm(glue("HDS_richness ~ {.x} * region"), HDS)) %>%
  set_names(predictor_names) %>%
  {tibble(predictor = names(.), model = .)} %>%
  mutate(
    slope_p_value  = map_dbl(model, ~tidy(.x)$p.value[[2]]),
    region_p_value = map_dbl(model, ~tidy(.x)$p.value[[3]]),
    int_p_value    = map_dbl(model, ~tidy(.x)$p.value[[4]]),
    r_squared      = map_dbl(model, ~glance(.x)$r.squared),
    slope_sig      = ifelse(slope_p_value  <= 0.05, "*", ""),
    region_sig     = ifelse(region_p_value <= 0.05, "*", ""),
    int_sig        = ifelse(int_p_value    <= 0.05, "*", ""),
    plot = map2(model, predictor,
      ~ visreg::visreg(.x,
        xvar    = .y,
        by      = "region",
        overlay = TRUE,
        gg      = TRUE
      )
    )
  )
```

```{r}
HDS_richness_models_no_region %>%
  dplyr::select(
    predictor,     r_squared,
    slope_p_value, slope_sig
  ) %>%
  mutate_if(is.numeric, ~format(round(.x, digits = 3), nsmall = 3)) %>%
  knitr::kable(
    caption = paste(
      "Results of separate simple linear regressions of $S_{\\mathrm{HDS}}$",
      "against environmental heterogeneity variables",
      "with no region-term."
    ),
    col.names = c(
      "Predictor",   "$R^2$",
      "$P_{slope}$", ""
    ),
    align = "lrrc"
  )
```

```{r}
HDS_richness_models_add_region %>%
  dplyr::select(
    predictor,      r_squared,
    slope_p_value,  slope_sig,
    region_p_value, region_sig
  ) %>%
  mutate_if(is.numeric, ~format(round(.x, digits = 3), nsmall = 3)) %>%
  knitr::kable(
    caption = paste(
      "Results of separate simple linear regressions of $S_{\\mathrm{HDS}}$",
      "against environmental heterogeneity variables",
      "with an additive region-term."
    ),
    col.names = c(
      "Predictor",    "$R^2$",
      "$P_{slope}$",  "",
      "$P_{region}$", ""
    ),
    align = "lrrcrc"
  )
```

```{r}
HDS_richness_models_int_region %>%
  dplyr::select(
    predictor,      r_squared,
    slope_p_value,  slope_sig,
    region_p_value, region_sig,
    int_p_value,    int_sig
  ) %>%
  mutate_if(is.numeric, ~format(round(.x, digits = 3), nsmall = 3)) %>%
  knitr::kable(
    caption = paste(
      "Results of separate simple linear regressions of $S_{\\mathrm{HDS}}$",
      "against environmental heterogeneity variables",
      "with an interaction-region-term."
    ),
    col.names = c(
      "Predictor",          "$R^2$",
      "$P_{slope}$",        "",
      "$P_{region}$",       "",
      "$P_{slope:region}$", ""
    ),
    align = "lrrcrcrc"
  )
```

```{r, eval=FALSE}
HDS_richness_models_no_region$plot[c(2, 3, 5, 6, 8, 9)] %<>%
  map(~ .x + theme(
    axis.title.y = element_blank(),
    axis.text.y  = element_blank(),
    axis.ticks.y = element_blank()
  ))
HDS_richness_models_add_region$plot[c(2, 3, 5, 6, 8, 9)] %<>%
  map(~ .x + theme(
    axis.title.y = element_blank(),
    axis.text.y  = element_blank(),
    axis.ticks.y = element_blank()
  ))
HDS_richness_models_add_region$plot[c(1, 2, 4, 5, 7, 8)] %<>%
  map(~ .x + theme(legend.position = "none"))
HDS_richness_models_int_region$plot[c(2, 3, 5, 6, 8, 9)] %<>%
  map(~ .x + theme(
    axis.title.y = element_blank(),
    axis.text.y  = element_blank(),
    axis.ticks.y = element_blank()
  ))
HDS_richness_models_int_region$plot[c(1, 2, 4, 5, 7, 8)] %<>%
  map(~ .x + theme(legend.position = "none"))

plot_grid(plotlist = HDS_richness_models_no_region$plot)
plot_grid(plotlist = HDS_richness_models_add_region$plot)
plot_grid(plotlist = HDS_richness_models_int_region$plot)
```

\clearpage

### 3.2.2. PC1 models

Here, I present my findings with raw R-code, because I don't have the time to format it neatly.

```{r, echo=TRUE}
# Richness (HDS)

m1 <- lm(HDS_richness ~ PC1,          filter(HDS, n_QDS == 4))
m2 <- lm(HDS_richness ~ PC1 + region, filter(HDS, n_QDS == 4))
m3 <- lm(HDS_richness ~ PC1 : region, filter(HDS, n_QDS == 4))
m4 <- lm(HDS_richness ~ PC1 * region, filter(HDS, n_QDS == 4))
AIC(m1, m2, m3, m4)

summary(m1)

ggplot(filter(HDS, n_QDS == 4), aes(PC1, HDS_richness)) +
  geom_smooth(method = lm, colour = "grey25") +
  geom_point(aes(fill = region), shape = 21, colour = "black") +
  ylab(bquote(italic("S")["HDS"])) +
  scale_fill_manual(name = "Region", values = c("black", "white"))
```

```{r}
# Richness (QDS)

m1 <- lm(QDS_richness ~ PC1,          filter(QDS, n_EDS == 4))
m2 <- lm(QDS_richness ~ PC1 + region, filter(QDS, n_EDS == 4))
m3 <- lm(QDS_richness ~ PC1 : region, filter(QDS, n_EDS == 4))
m4 <- lm(QDS_richness ~ PC1 * region, filter(QDS, n_EDS == 4))

AIC(m1, m2, m3, m4)

summary(m2)

visreg::visreg(m2, xvar = "PC1", by = "region", overlay = TRUE)
```

```{r}
# Turnover

m1 <- lm(add_turnover ~ PC1,          filter(HDS, n_QDS == 4))
m2 <- lm(add_turnover ~ PC1 + region, filter(HDS, n_QDS == 4))
m3 <- lm(add_turnover ~ PC1 * region, filter(HDS, n_QDS == 4))

AIC(m1, m2, m3)

summary(m1)

visreg::visreg(m1)

# Turnover (proportional)

m1 <- lm(add_turnover_prop ~ PC1 + PC2,          filter(HDS, n_QDS == 4))
m2 <- lm(add_turnover_prop ~ PC1 + PC2 + region, filter(HDS, n_QDS == 4))
m3 <- lm(add_turnover_prop ~ PC1 * region + PC2 * region, filter(HDS, n_QDS == 4))

AIC(m1, m2, m3)

summary(m3)

visreg::visreg(m3, xvar = "PC1", by = "region", overlay = TRUE)
visreg::visreg(m3, xvar = "PC2", by = "region", overlay = TRUE)
```

```{r}
HDS %>%
  filter(n_QDS == 4) %>%
  gather(metric, value, HDS_richness, add_turnover_prop) %>%
  ggplot(aes(PC1, value)) +
    geom_smooth(method = lm, colour = "grey25") +
    geom_point(aes(fill = region), shape = 21, colour = "black") +
    scale_fill_manual(name = "Region", values = c("black", "white")) +
    facet_grid(metric ~ ., scales = "free_y")
HDS %>%
  filter(n_QDS == 4) %>%
  gather(metric, value, HDS_richness, add_turnover) %>%
  ggplot(aes(PC1, value)) +
    geom_smooth(method = lm, colour = "grey25") +
    geom_point(aes(fill = region), shape = 21, colour = "black") +
    scale_fill_manual(name = "Region", values = c("black", "white")) +
    facet_grid(metric ~ ., scales = "free_y")
```

## 3.3. Combined-regions models with combinations of variables

[To be discussed in meeting.]

```{r}, eval=FALSE, echo=FALSE}

# TODO

m_all <- lm(
  HDS_richness ~
    Elevation_mean_value + Elevation_roughness +
    MAP_mean_value       + MAP_roughness +
    NDVI_mean_value      + NDVI_roughness +
    PDQ_mean_value       + PDQ_roughness +
    pH_mean_value        + pH_roughness +
    Soil.C_mean_value    + Soil.C_roughness +
    Surface.T_mean_value + Surface.T_roughness,
  HDS
)
summary(m_all)
m_all_step <- step(m_all)
summary(m_all_step)

m_all_int <- lm(
  HDS_richness ~
    Elevation_mean_value          + Elevation_roughness +
    MAP_mean_value                + MAP_roughness +
    NDVI_mean_value               + NDVI_roughness +
    PDQ_mean_value                + PDQ_roughness +
    pH_mean_value                 + pH_roughness +
    Soil.C_mean_value             + Soil.C_roughness +
    Surface.T_mean_value          + Surface.T_roughness +
    Elevation_mean_value * region + Elevation_roughness * region +
    MAP_mean_value       * region + MAP_roughness       * region +
    NDVI_mean_value      * region + NDVI_roughness      * region +
    PDQ_mean_value       * region + PDQ_roughness       * region +
    pH_mean_value        * region + pH_roughness        * region +
    Soil.C_mean_value    * region + Soil.C_roughness    * region +
    Surface.T_mean_value * region + Surface.T_roughness * region,
  HDS
)
m_all_int2 <- lm(
  QDS_richness ~
    Elevation_mean_value          + Elevation_roughness +
    MAP_mean_value                + MAP_roughness +
    NDVI_mean_value               + NDVI_roughness +
    PDQ_mean_value                + PDQ_roughness +
    pH_mean_value                 + pH_roughness +
    Soil.C_mean_value             + Soil.C_roughness +
    Surface.T_mean_value          + Surface.T_roughness +
    Elevation_mean_value * region + Elevation_roughness * region +
    MAP_mean_value       * region + MAP_roughness       * region +
    NDVI_mean_value      * region + NDVI_roughness      * region +
    PDQ_mean_value       * region + PDQ_roughness       * region +
    pH_mean_value        * region + pH_roughness        * region +
    Soil.C_mean_value    * region + Soil.C_roughness    * region +
    Surface.T_mean_value * region + Surface.T_roughness * region,
  QDS
)
summary(m_all_int)
summary(m_all_int2)
m_all_int_step <- step(m_all_int)
m_all_int_step2 <- step(m_all_int2)
summary(m_all_int_step)
summary(m_all_int_step2)
non_sigs <- m_all_int_step %>%
  tidy() %>%
  filter(p.value > 0.05, term != "(Intercept)") %>%
  pull(term) %>%
  paste(collapse = " - ") %>%
  {paste("-", .)}

m_all_int_step_manual <- update(
  m_all_int_step,
  as.formula(paste("~ .", non_sigs))
)
summary(m_all_int_step_manual)
non_sigs <- m_all_int_step_manual %>%
  tidy() %>%
  filter(p.value > 0.05, term != "(Intercept)") %>%
  pull(term) %>%
  paste(collapse = " - ") %>%
  {paste("-", .)}
m_all_int_step_manual2 <- update(
  m_all_int_step_manual,
  as.formula(paste("~ .", non_sigs))
)
summary(m_all_int_step_manual2)

AIC(m_all, m_all_step, m_all_int, m_all_int_step)

foo <- tibble(
  fit    = m_all_int_step$fitted.values,
  obs    = HDS$HDS_richness,
  region = HDS$region
)
ggplot(foo, aes(obs, fit)) +
  geom_smooth(method = lm, colour = "black") +
  geom_point(aes(colour = region))
#plot(m_all_int_step)

foo2 <- tibble(
  fit    = m_all_int_step2$fitted.values,
  obs    = QDS$QDS_richness,
  region = QDS$region
)
ggplot(foo2, aes(obs, fit)) +
  geom_smooth(method = lm, colour = "black") +
  geom_point(aes(colour = region), alpha = 0.25)
#plot(m_all_int_step2)

# (*) Plots --------------------------------------------------------------------

ggplot(HDS, aes(PC1, HDS_richness)) +
  geom_point(aes(colour = region)) +
  geom_smooth(method = lm, colour = "black")
ggplot(QDS, aes(PC1, QDS_richness)) +
  geom_point(aes(colour = region)) +
  geom_smooth(method = lm, colour = "black")
m <- lm(HDS_richness ~ PC1, HDS)
#plot(m)
ggplot(HDS, aes(Elevation_mean_value, HDS_richness)) +
  geom_point(aes(colour = region)) +
  geom_smooth(method = lm, colour = "black")
ggplot(HDS, aes(Elevation_roughness, HDS_richness)) +
  geom_point(aes(colour = region)) +
  geom_smooth(method = lm, colour = "black")

ggplot(HDS, aes(PC1, Elevation_roughness, colour = region)) +
  geom_point()
ggplot(HDS, aes(PC2, Elevation_roughness, colour = region)) +
  geom_point()

ggplot(QDS, aes(lon, lat, colour = PC1)) +
  geom_point(size = 3) +
  facet_grid(~region, scales = "free_x") +
  scale_colour_viridis_c()

ggplot(HDS, aes(lon, lat, colour = PC1)) +
  geom_point(size = 3) +
  facet_wrap(~region, scales = "free") +
  scale_colour_viridis_c()
ggplot(HDS, aes(lon, lat, colour = PC2)) +
  geom_point(size = 3) +
  facet_wrap(~region, scales = "free")

# (...) PCA biplots again ------------------------------------------------------

HDS_PCA      <- read_rds(here("outputs/QDS_roughness_cells_PCA.RDS"))
HDS_PCA_data <- read_csv(here("outputs/QDS_roughness_cells_prepped.csv"))
QDS_PCA      <- read_rds(here("outputs/EDS_roughness_cells_PCA.RDS"))
QDS_PCA_data <- read_csv(here("outputs/EDS_roughness_cells_prepped.csv"))

# Log to match PCA
HDS_PCA_data[, -c(1, 2)] %<>% log()
QDS_PCA_data[, -c(1, 2)] %<>% log()

autoplot(HDS_PCA,
  data            = HDS_PCA_data,
  colour          = "region",
  loadings        = TRUE,
  loadings.colour = "blue",
  loadings.label  = TRUE
)
autoplot(QDS_PCA,
  data            = QDS_PCA_data,
  colour          = "region",
  loadings        = TRUE,
  loadings.colour = "blue",
  loadings.label  = TRUE
)

HDS %>%
  filter(n_QDS == 4) %>%
  dplyr::select(region, PC1, PC2) %>%
  group_by(region) %>%
  summarise_all(.funs = list(mean = mean, sd = sd)) %>%
  mutate(
    PC1_upp = PC1_mean + PC1_sd,
    PC1_low = PC1_mean - PC1_sd,
    PC2_upp = PC2_mean + PC2_sd,
    PC2_low = PC2_mean - PC2_sd
  ) %>%
  ggplot(aes(PC1_mean, PC2_mean, colour = region)) +
    geom_hline(yintercept = 0, lty = "dashed", colour = "grey25") +
    geom_vline(xintercept = 0, lty = "dashed", colour = "grey25") +
    geom_point() +
    geom_errorbar( aes(ymin = PC2_low, ymax = PC2_upp), width  = 0) +
    geom_errorbarh(aes(xmin = PC1_low, xmax = PC1_upp), height = 0) +
    geom_point(
      data    = filter(HDS, n_QDS == 4),
      mapping = aes(PC1, PC2, colour = region),
      alpha   = 0.5
    ) +
    theme_minimal()

QDS %>%
  filter(n_EDS == 4) %>%
  dplyr::select(region, PC1, PC2) %>%
  group_by(region) %>%
  summarise_all(.funs = list(mean = mean, sd = sd)) %>%
  mutate(
    PC1_upp = PC1_mean + PC1_sd,
    PC1_low = PC1_mean - PC1_sd,
    PC2_upp = PC2_mean + PC2_sd,
    PC2_low = PC2_mean - PC2_sd
  ) %>%
  ggplot(aes(PC1_mean, PC2_mean, colour = region)) +
    geom_hline(yintercept = 0, lty = "dashed", colour = "grey25") +
    geom_vline(xintercept = 0, lty = "dashed", colour = "grey25") +
    geom_point() +
    geom_errorbar( aes(ymin = PC2_low, ymax = PC2_upp), width  = 0) +
    geom_errorbarh(aes(xmin = PC1_low, xmax = PC1_upp), height = 0) +
    geom_point(
      data    = filter(QDS, n_EDS == 4),
      mapping = aes(PC1, PC2, colour = region),
      alpha   = 0.25
    ) +
    theme_minimal()

ggplot(HDS, aes(PC1, PC2, colour = PC2 > 0)) +
  geom_point()

HDS %>%
  split(.$region) %>%
  map(~.x %$% table(PC2 > 0, PC1 > 0))

my_PCA_plot <- function(data) {
  get_lim <- function(x) {
    lim <- ceiling(max(x))
    c(-lim, lim)
  }
  plot_xlim <- get_lim(data$PC1)
  plot_ylim <- get_lim(data$PC2)
  no_legend_no_grid <- theme(
    legend.position  = "none",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
  white_rect <- grid::grid.rect(gp = grid::gpar(col = "white"))

  PC1_histograms <- ggplot(data, aes(PC1, fill = region)) +
    geom_histogram(bins = 20, position = "dodge") +
    xlim(plot_xlim) +
    theme_minimal() +
    theme(
      axis.title.x       = element_blank(),
      axis.text.x        = element_blank(),
      axis.text.y        = element_text(angle = 90),
      axis.line.x.bottom = element_blank(),
      axis.line.x.top    = element_blank(),
      axis.line.y.right  = element_blank()
    ) +
    no_legend_no_grid
  PC2_histograms <- ggplot(data, aes(PC2, fill = region)) +
    geom_histogram(bins = 20, position = "dodge") +
    xlim(plot_ylim) +
    coord_flip() +
    theme_minimal() +
    theme(
      axis.title.y       = element_blank(),
      axis.text.y        = element_blank(),
      axis.line.y.right  = element_blank(),
      axis.line.y.left   = element_blank(),
      axis.line.x.top    = element_blank()
    ) +
    no_legend_no_grid

  PCA_biplot <- ggplot(data, aes(PC1, PC2, colour = region)) +
    geom_hline(yintercept = 0, lty = "dashed", colour = "grey25") +
    geom_vline(xintercept = 0, lty = "dashed", colour = "grey25") +
    geom_point() +
    lims(x = plot_xlim, y = plot_ylim) +
    theme_bw() +
    theme(axis.text.y = element_text(angle = 90)) +
    no_legend_no_grid

  cowplot::plot_grid(
    PC1_histograms, white_rect,
    PCA_biplot,     PC2_histograms,
    ncol = 2,
    rel_widths = c(4, 1), rel_heights = c(1, 4)
  )
}
foo <- my_PCA_plot(HDS)
foo
PC1_histograms <- ggplot(QDS, aes(PC1, fill = region)) +
  xlim(-5, 5) +
  geom_histogram(bins = 20, position = "dodge") +
  theme_minimal() +
  theme(legend.position = "none", axis.title.x = element_blank(),
                                  axis.text.x = element_blank(),
                                  axis.text.y = element_text(angle = 90),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
PC2_histograms <- ggplot(QDS, aes(PC2, fill = region)) +
  xlim(-5, 5) +
  geom_histogram(bins = 20, position = "dodge") +
  coord_flip() +
  theme_minimal() +
  theme(legend.position = "none", axis.title.y = element_blank(),
                                  axis.text.y = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
PC_biplot <- ggplot(QDS, aes(PC1, PC2, colour = region)) +
  lims(x = c(-5, 5), y = c(-5, 5)) +
  geom_hline(yintercept = 0, lty = "dashed", colour = "grey25") +
  geom_vline(xintercept = 0, lty = "dashed", colour = "grey25") +
  geom_point() +
  theme_bw() +
  theme(legend.position = "none", axis.text.y = element_text(angle = 90),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

white_rect <- grid::grid.rect(gp = grid::gpar(col = "white"))
cowplot::plot_grid(
  PC1_histograms, white_rect,
  PC_biplot,      PC2_histograms,
  ncol = 2,
  rel_widths = c(4, 1), rel_heights = c(1, 4)
)

PC1_histograms <- ggplot(HDS, aes(PC1, fill = region)) +
  #xlim(-5, 5) +
  geom_histogram(bins = 20, position = "dodge") +
  theme_minimal() +
  theme(legend.position = "none", axis.title.x = element_blank(),
                                  axis.text.x = element_blank(),
                                  axis.title.y = element_blank(),
                                  axis.text.y = element_blank(),
                                  #axis.text.y = element_text(angle = 90),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
PC2_histograms <- ggplot(HDS, aes(PC2, fill = region)) +
  #xlim(-5, 5) +
  geom_histogram(bins = 20, position = "dodge") +
  coord_flip() +
  theme_minimal() +
  theme(legend.position = "none", axis.title.y = element_blank(),
                                  axis.text.y = element_blank(),
                                  axis.title.x = element_blank(),
                                  axis.text.x = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
PC_biplot <- ggplot(HDS, aes(PC1, PC2, colour = region)) +
  #lims(x = c(-5, 5), y = c(-5, 5)) +
  geom_hline(yintercept = 0, lty = "dashed", colour = "grey25") +
  geom_vline(xintercept = 0, lty = "dashed", colour = "grey25") +
  geom_point() +
  theme_bw() +
  theme(legend.position = "none", axis.text.y = element_text(angle = 90),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

white_rect <- grid::grid.rect(gp = grid::gpar(col = "white"))
cowplot::plot_grid(
  PC1_histograms, white_rect,
  PC_biplot,      PC2_histograms,
  ncol = 2,
  rel_widths = c(4, 1), rel_heights = c(1, 4)
)

all_PCA_data <- rbind(
  cbind(scale = "HDS", HDS_PCA_data[, -2]),
  cbind(scale = "QDS", QDS_PCA_data[, -2])
)

foo <- prcomp(all_PCA_data[, -c(1, 2)], scale. = TRUE)
if (all(foo$rotation[, 1] <= 0)) {
  foo$rotation[, 1] %<>% multiply_by(-1)
  foo$x[, 1]        %<>% multiply_by(-1)
}
autoplot(foo, data = unite(all_PCA_data, region_scale, region, scale), colour = "region_scale", alpha = 0.25)
```
