---
title: "Analyses v2"
subtitle: "Cape vs SWA"
author: "Ruan van Mazijk"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(here)
source(here("analyses-May-2019/setup.R"))
```

# Preamble/outline

Here I layout the "new", second incarnation of the analyses as discussed over the course of May/June 2019, following the first draft of the manuscript.

The proposed "story" of questions for the analyses as as follows:

1. _Is SWA more heterogeneous environmentally than the Cape, and does the scale of that heterogeneity differ to that of the Cape?_
2. _Do the regions differ w.r.t. the species richness of both HDS and QDS cells, and, for HDS cells' richness ($S_{HDS}$), does the explanatory power of mean QDS richness ($S_{QDS}$) and turnover ($T_{QDS}$) differ between the regions?_
3. _Does heterogeneity explain differences in richness and turnover between the regions?_

# 1. Environmental heterogeneity & scale

_Is the Cape for environmentalyl heterogeneous than SWA, and does the scale of that heterogeneity differ to that of SWA?_

For this question, environmental roughness in both regions was calculated, in moving 3 x 3 cell windows, as the average absolute difference between cells and their (usually) 8 neighbours. Alternatively, for a focal cell $x^*$, the roughness is based on $x_1, x_2, \dots, x_i, \dots, x_8$ neighbour cells as:

\begin{align*}
  Roughness(x^*) =
    f \left( \begin{matrix}
      x_1 & x_2 & x_3 \\
      x_4 & x^* & x_5 \\
      x_6 & x_7 & x_8
    \end{matrix} \right) =
    \frac{1}{n} \sum_{i=1}^n |x^* - x_i|
\end{align*}

In R, I have implemented this as follows:

```{r print-roughness-body, eval=FALSE}
roughness <- function(x) {
  raster::focal(x, matrix(1, nrow = 3, ncol = 3), function(x) {
    focal_cell <- x[5]
    neighbour_cells <- x[
      !is.na(x) &
      !is.nan(x) &
      x != focal_cell
    ]
    ifelse(!is.na(focal_cell) & !is.nan(focal_cell),
      mean(abs(focal_cell - neighbour_cells)),
      NA
    )
  })
}
```

\clearpage

## 1.1. Ordinating environmental heterogeneity

Here, I $log(x+1)$-transform and perform a scaled and centred PCA of the roughness values as defined above, at each of five spatial scales: the base data resolution (0.05ยบ x 0.05ยบ), eighth- (EDS), quarter- (QDS), half- (HDS) and three-quarter-degree-squares (3QDS).

```{r import-roughness-matrices, include=FALSE}
output_path      <- here("outputs/roughness")
resolutions      <- c("base", "EDS", "QDS", "HDS", "3QDS")
matrix_filenames <- glue("{output_path}/{resolutions}_roughness_matrix.csv")

roughness_matrices <- map(matrix_filenames, read_csv)
names(roughness_matrices) <- resolutions
```

The data matrices for each scale for this PCA look like this (and obviously the "region" column was excluded from the PCA proper):

```{r print-roughness-matrix-example, echo=FALSE}
roughness_matrices %$%
  base %>%
  mutate_if(is.numeric, log1p) %>%
  mutate_if(is.numeric, round, digits = 2) %>%
  {rbind(head(.), rep("...", 11), tail(.))} %>%
  knitr::kable(caption =
    "Portions of the data matrices used in the PCA for this analysis."
  )
```

```{r PCA-analysis, include=FALSE}
roughness_PCAs <- map(roughness_matrices,
  ~ .x[, -1] %>%
    log1p() %>%
    prcomp(scale. = TRUE)
)

# Force PC1 scores to be positive if all vars rotations are negative
roughness_PCAs %<>% map(function(PCA) {
  if (all(PCA$rotation[, 1] <= 0)) {
    PCA$rotation[, 1] %<>% multiply_by(-1)
    PCA$x[, 1]        %<>% multiply_by(-1)
  }
  PCA
})

# Store PC1 & 2 in matrices for later
roughness_matrices <- map2(roughness_PCAs, roughness_matrices,
  function(PCA, layer) {
    layer$PC1 <- PCA$x[, 1]
    layer$PC2 <- PCA$x[, 2]
    layer
  }
)
```

Plot PC1 vs PC2 at each scale:

```{r plot-PCA, echo=FALSE, fig.height=8}
roughness_PCA_plots <- map2(roughness_PCAs, roughness_matrices,
  ~ autoplot(.x,
      data = .y, colour = "region", alpha = 0.25,
      loadings = TRUE, loadings.colour = "black",
      loadings.label = TRUE, loadings.label.colour = "black",
      loadings.label.hjust = -0.25
    ) +
    geom_hline(yintercept = 0, lty = "dashed", alpha = 0.5) +
    geom_vline(xintercept = 0, lty = "dashed", alpha = 0.5) + 
    scale_color_manual(name = "Region", values = my_palette)
)
my_legend <- get_legend(roughness_PCA_plots[[1]])
roughness_PCA_plots %<>% map(~.x + theme(legend.position = "none"))
roughness_PCA_plots <- c(roughness_PCA_plots, my_legend = list(my_legend))
plot_grid(
  plotlist = roughness_PCA_plots,
  labels   = names(roughness_PCA_plots),
  nrow     = 3
)
```

Plot maps of exemplary roughness variables and PC1

```{r map-PCA}
# TODO
```

\clearpage

## 1.2. Effect size of Cape vs SWA heterogeneity

I calculated the $CLES$ of Cape > SWA untransformed roughness and PC1 values (from the analysis above).

```{r CLES-analysis, include=FALSE}
GCFR_roughness_data <- roughness_matrices %>%
  map(filter, region == "GCFR") %>%
  map(dplyr::select, -region, -PC2)
SWAFR_roughness_data <- roughness_matrices %>%
  map(filter, region == "SWAFR") %>%
  map(dplyr::select, -region, -PC2)

# (WARNING: this takes a while... Only run if haven't already...)
if (!file.exists(glue("{output_path}/CLES_results.csv"))) {
  set.seed(1234)
  CLES_results <- map2_df(GCFR_roughness_data, SWAFR_roughness_data,
    .id = "resolution",  # for every spatial resolution,
    ~ map2_df(.x, .y,
      .id = "variable",  # for every variable in each region,
      ~tibble(CLES_value = CLES(.y, .x))
    )
  )
  # Save results to disc
  write_csv(
    CLES_results,
    glue("{output_path}/CLES_results.csv")
  )
} else {  # (... Or import from disc.)
  CLES_results <- read_csv(glue("{output_path}/CLES_results.csv"))
}

# Tidy
CLES_results %<>%
  filter(variable != "region", variable != "PC2") %>%
  mutate(resolution = case_when(
    resolution == "base" ~ 0.05,
    resolution == "EDS"  ~ 0.125,
    resolution == "QDS"  ~ 0.25,
    resolution == "HDS"  ~ 0.50,
    resolution == "3QDS" ~ 0.75
  )) %>%
  mutate(variable_type = case_when(
    variable == "PC1"                          ~ "PC1",
    variable == "Elevation"                    ~ "Elevation",
    variable == "NDVI"                         ~ "NDVI",
    variable %in% c("MAP", "PDQ", "Surface.T") ~ "Climate",
    TRUE                                       ~ "Soil"
  )) %>%
  mutate(variable_type = factor(variable_type, levels = c(
    "Elevation",
    "Climate",
    "NDVI",
    "Soil",
    "PC1"
  ))) %>%
  mutate(variable = factor(variable, levels = c(
    "Elevation",
    "MAP", "PDQ", "Surface.T",
    "NDVI",
    "CEC", "Clay", "Soil.C", "pH",
    "PC1"
  )))
```

Let's lot $CLES$ vs scale for each variable:

```{r plot-CLES, echo=FALSE}
CLES_plots <- ggplot(CLES_results) +
  aes(resolution, CLES_value, colour = variable_type) +
  geom_hline(yintercept = 0.5, lty = "dashed") +
  geom_point() +
  facet_wrap(~variable, nrow = 2) +
  scale_x_continuous(
    name   = "Scale",
    breaks = c(0.05,   0.125, 0.25,  0.50,  0.75),
    labels = c("0.05ยบ", "EDS", "QDS", "HDS", "3QDS")
  ) +
  scale_y_continuous(
    name   = "CLES\n(GCFR > SWAFR)",
    breaks = c(0.50, 0.75, 1.00)      
  ) +
  scale_colour_manual(values = var_colours) +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 90)
  )
CLES_plots
```

Let's regress $CLES$ against scale for each of these panels:

```{r model-CLES, echo=FALSE}
CLES_models <- CLES_results %>%
  split(.$variable) %>%
  map(~lm(CLES_value ~ resolution, .x))
CLES_model_summaries <- CLES_models %>%
  map_df(.id = "variable", ~ cbind(
    .x %>% 
      tidy() %>% 
      filter(term != "(Intercept)") %>% 
      dplyr::select(estimate, p.value),
    .x %>%
      glance() %>%
      dplyr::select(r.squared)
  )) %>%
  rename(slope = estimate) %>%
  mutate(
    sig = case_when(
      p.value <= 0.05 ~ "*",
      p.value <= 0.10 ~ ".",
      TRUE            ~ ""
    ),
    slope_sign = case_when(
      sig != "" & slope > 0 ~ "+",
      sig != "" & slope < 0 ~ "-",
      TRUE                   ~ ""
    )
  ) %>%
  arrange(desc(sig), slope_sign) %>%
  mutate_if(is.numeric, round, digits = 3)
knitr::kable(CLES_model_summaries, align = "lrrrcc", caption = paste(
  "Slopes, significances and $R^2$-values from regressions",
  "of $CLES$ against each form of environmental roughness."
))
```

CEC is on the verge of significant, so I will still plot it ($P = 0.063$). Let's plot those significant fits then:

```{r plot-CLES-fits, echo=FALSE}
CLES_results_sans_NS <- mutate(CLES_results,
  CLES_value = ifelse(variable %in% c("NDVI", "PDQ", "pH"),
    NA,
    CLES_value
  )
)
CLES_plots + geom_smooth(
  mapping = aes(group = variable),
  method  = lm,
  data    = CLES_results_sans_NS
)
```

# 2. Species richness & turnover

_Do the regions differ w.r.t. the species richness of both HDS and QDS cells, and, for HDS cells' richness ($S_{HDS}$), does the explanatory power of mean QDS richness ($S_{QDS}$) and turnover ($T_{QDS}$) differ between the regions?_

To tackle this question, I compare measures of species richness and turnover between the regions in both univariate and multivariate/model analyses.

## 2.1. Univariate comparisons

```{r import-cellular-data, include=FALSE}
HDS <- read_csv(here("outputs/QDS_data_cells.csv"))
QDS <- read_csv(here("outputs/EDS_data_cells.csv"))
HDS_QDS <- as_tibble(rbind(
  HDS %>%
    dplyr::select(region, HDS_richness, mean_QDS_richness, mul_turnover, n_QDS) %>%
    mutate(add_turnover = HDS_richness - (mean_QDS_richness * n_QDS)) %>%
    rename(n_subcells = n_QDS) %>%
    gather(metric, value, HDS_richness, mean_QDS_richness, mul_turnover, add_turnover),
  QDS %>%
    dplyr::select(region, QDS_richness, n_EDS) %>%
    rename(n_subcells = n_EDS) %>%
    gather(metric, value, QDS_richness)
))
```

What do the data look like?

```{r plot-richness-turnover-univariate, echo=FALSE, fig.height=2}
ggplot(HDS_QDS, aes(value, fill = region)) +
  geom_histogram(bins = 20, position = "dodge") +
  scale_fill_manual(name = "Region", values = my_palette) +
  facet_wrap(~metric, nrow = 1, scales = "free")
```

Are there significant differences between GCFR and SWAFR values?

```{r test-richness-turnover-univariate, echo=FALSE}
HDS_QDS %>%
  group_by(metric) %>%
  summarise(
    U_test = wilcox.test(value[region == "SWAFR"], value[region == "GCFR"]) %>%
      tidy() %>%
      list(),
    U = map_dbl(U_test, "statistic"),
    P = map_dbl(U_test, "p.value"),
    CLES_value = CLES(value[region == "SWAFR"], value[region == "GCFR"])
  ) %>%
  mutate(sig = ifelse(P <= 0.05, "*", "")) %>%
  dplyr::select(-U_test) %>%
  dplyr::select(metric, U, P, sig, CLES_value) %>%
  knitr::kable(caption = paste(
    "Results of Mann-Whitney $U$-tests and the $CLES$ of GCFR vs SWAFR",
    "QDS and HDS richness and multiplicative turnover."
  ))
```

## 2.2. Multivariate comparisons & models

Before I get stuck in with modelling HDS richness as a function of QDS richness and turnover, let's wrap our heads around the dataset first, with special attention to how the number of constituent QDS in HDS affects the patterns:

```{r explore-HDS-cellular-data, echo=FALSE}
HDS %>%
  gather(partition, value, mean_QDS_richness, mul_turnover) %>%
  ggplot(aes(value, HDS_richness, colour = region)) +
    geom_point(aes(alpha = n_QDS)) +
    scale_colour_manual(name = "Region", values = my_palette) +
    scale_alpha_continuous(
      name   = "No. QDS", 
      breaks = c(2, 3, 4), 
      range  = c(1, 0.25)
    ) +
    facet_grid(region ~ partition, scales = "free_x")
```


```{r correct-for-n-QDS, echo=FALSE}
HDS %>%
  mutate(mul_turnover = (HDS_richness / n_QDS) / mean_QDS_richness) %>%
  gather(partition, value, mean_QDS_richness, mul_turnover) %>%
  ggplot(aes(value, HDS_richness, colour = region)) +
    geom_point(aes(alpha = n_QDS)) +
    scale_colour_manual(name = "Region", values = my_palette) +
    scale_alpha_continuous(
      name   = "No. QDS", 
      breaks = c(2, 3, 4), 
      range  = c(1, 0.25)
    ) +
    facet_grid(region ~ partition, scales = "free_x")
HDS %>%
  mutate(add_turnover = (HDS_richness - mean_QDS_richness) / n_QDS) %>%
  gather(partition, value, mean_QDS_richness, add_turnover) %>%
  ggplot(aes(HDS_richness, value, colour = region)) +
    geom_point(aes(alpha = n_QDS)) +
    scale_colour_manual(name = "Region", values = my_palette) +
    scale_alpha_continuous(
      name   = "No. QDS", 
      breaks = c(2, 3, 4), 
      range  = c(1, 0.25)
    ) +
    facet_grid(partition ~ ., scales = "free_y")
m1 <- lm(add_turnover ~ HDS_richness * region, mutate(HDS, add_turnover = (HDS_richness - mean_QDS_richness) / n_QDS))
m2 <- lm(mean_QDS_richness ~ HDS_richness * region, HDS)
summary(m1)
summary(m2)
visreg::visreg(m1, xvar = "HDS_richness", by = "region", overlay = TRUE)
visreg::visreg(m2, xvar = "HDS_richness", by = "region", overlay = TRUE)

plot(mean_QDS_richness ~ add_turnover, mutate(HDS, add_turnover = (HDS_richness - mean_QDS_richness)))
abline(0, 1)

HDS2 <- HDS %>%
  #filter(n_QDS == 4) %>%
  mutate(add_turnover = (HDS_richness - mean_QDS_richness))
foo <- ceiling(max(c(HDS2$mean_QDS_richness, HDS2$add_turnover))) + 10
ggplot(HDS2, aes(add_turnover, mean_QDS_richness, colour = region)) +
  geom_tile(
    data = seq(0, foo, 10) %>%
      {expand.grid(x = ., y = .)} %>%
      mutate(z = x + y),
    mapping = aes(x, y, fill = z), colour = NA
  ) +
  labs(x = bquote(italic("T")["QDS"]), y = bquote(italic("S")["QDS"])) +
  scale_fill_gradient(
    name = bquote(italic("S")["HDS"]),
    low  = "white",
    high = "grey"
  ) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  geom_point(
    data    = HDS2,
    mapping = aes(add_turnover, mean_QDS_richness, colour = region),
    alpha   = 0.5
  ) +
  scale_colour_manual(name = "Region", values = my_palette)

HDS %>%
  mutate(add_turnover = (HDS_richness - mean_QDS_richness)) %>%
  gather(partition, value, mean_QDS_richness, add_turnover) %>%
  ggplot(aes(HDS_richness, value, colour = region)) +
    geom_point(aes(alpha = n_QDS)) +
    scale_colour_manual(name = "Region", values = my_palette) +
    scale_alpha_continuous(
      name   = "No. QDS", 
      breaks = c(2, 3, 4), 
      range  = c(1, 0.25)
    ) +
    facet_grid(~partition, scales = "free_x")

HDS %>%
  mutate(add_turnover = (HDS_richness - mean_QDS_richness)) %>%
  ggplot(aes(add_turnover, HDS_richness/mean_QDS_richness, colour = HDS_richness, shape = region)) +
    geom_abline(intercept = 0, slope = 1, linetype = "dashed", alpha = 0.5) +
    geom_point() +
    #lims(x = c(0, max(HDS$HDS_richness)), y = c(0, max(HDS$HDS_richness))) +
    scale_colour_viridis_c() #+
    #facet_grid(~region)
HDS %>%
  mutate(add_turnover = (HDS_richness - mean_QDS_richness)) %>%
  ggplot(aes(mean_QDS_richness, mean_QDS_richness + (mean_QDS_turnover * mean_QDS_richness) ^ (n_QDS - 1), colour = HDS_richness, shape = region)) +
    geom_abline(intercept = 0, slope = 1, linetype = "dashed", alpha = 0.5) +
    geom_point() +
    #lims(x = c(0, max(HDS$HDS_richness)), y = c(0, max(HDS$HDS_richness))) +
    scale_colour_viridis_c() #+
    #facet_grid(~region)
HDS %>%
  mutate(add_turnover = (HDS_richness - mean_QDS_richness)) %>%
  ggplot(aes(add_turnover / n_QDS, HDS_richness, colour = mean_QDS_richness, shape = region)) +
    geom_abline(intercept = 0, slope = 1, linetype = "dashed", alpha = 0.5) +
    geom_point() +
    #lims(x = c(0, max(HDS$HDS_richness)), y = c(0, max(HDS$HDS_richness))) +
    scale_colour_viridis_c() #+
    #facet_grid(~region)


foo <- HDS %>%
  mutate(add_turnover = (HDS_richness - mean_QDS_richness)) %>%
  {lm(
    HDS_richness ~
      mean_QDS_richness + 
      add_turnover +
      mean_QDS_richness * region + 
      add_turnover * region,
    .
  )}
visreg::visreg(foo, xvar = "mean_QDS_richness", by = "add_turnover", overlay = TRUE)

visreg::visreg(foo, xvar = "mean_QDS_richness", by = "region", overlay = TRUE)
```


```{r plot-richness-turnover-bivariate, eval=FALSE}

HDS %>%
  dplyr::select(region, HDS_richness, mean_QDS_richness, mean_QDS_turnover, mul_turnover) %>%
  gather(partition, value, -region, -HDS_richness) %>%
  ggplot(aes(value, HDS_richness, colour = region)) +
    geom_smooth(method = lme4::lmer, formula = y ~ x + (x | colour)) +
    geom_point() +
    facet_grid(~partition, scales = "free_x")

ggplot(HDS, aes(mul_turnover / n_QDS, HDS_richness / n_QDS, colour = region, size = mean_QDS_richness / n_QDS)) +
  geom_smooth(method = lm) +
  geom_point()

ggplot(HDS, aes(mean_QDS_turnover, HDS_richness, colour = region, size = mean_QDS_richness)) +
  geom_smooth(method = lm) +
  geom_point()

foo <- HDS %>%
  mutate(
    HDS_richness      = HDS_richness      / n_QDS,
    mean_QDS_richness = mean_QDS_richness / n_QDS,
    mul_turnover      = mul_turnover      / n_QDS
  ) %>%
  {lm(HDS_richness ~ mean_QDS_richness * mul_turnover, .)}
summary(foo)
visreg::visreg(foo, xvar = "mean_QDS_richness", by = "mul_turnover", breaks = 1, overlay = TRUE)
visreg::visreg(foo, xvar = "mul_turnover", by = "region", overlay = TRUE)

foo <- HDS %>%
  mutate(
    HDS_richness      = HDS_richness      / n_QDS,
    mean_QDS_richness = mean_QDS_richness / n_QDS
  ) %>%
  {lm(HDS_richness ~ mean_QDS_richness * mean_QDS_turnover + mean_QDS_richness * region + mean_QDS_turnover * region, .)}
summary(foo)
visreg::visreg(foo, xvar = "mean_QDS_richness", by = "mean_QDS_turnover", breaks = 3, overlay = TRUE)
visreg::visreg(foo, xvar = "mean_QDS_richness", by = "region", overlay = TRUE)
visreg::visreg(foo, xvar = "mean_QDS_turnover", by = "region", overlay = TRUE)

foo <- HDS %>%
  mutate(
    HDS_richness      = HDS_richness      / n_QDS,
    mean_QDS_richness = mean_QDS_richness / n_QDS,
    mul_turnover      = mul_turnover      / n_QDS
  )
bar <- list(
  lme4::lmer(HDS_richness ~ mul_turnover + (1 + mul_turnover |  region), foo),
  lme4::lmer(HDS_richness ~ mul_turnover + (1 + mul_turnover || region), foo),
  lme4::lmer(HDS_richness ~ mean_QDS_richness * mul_turnover + (1 + mul_turnover | region) + (1 + mean_QDS_richness | region), foo)
)
summary(bar[[1]])
visreg::visreg(bar[[1]], xvar = "mul_turnover", by = "region", overlay = TRUE)
visreg::visreg(bar[[2]], xvar = "mul_turnover", by = "region", overlay = TRUE)
visreg::visreg(bar[[3]], xvar = "mul_turnover", by = "region", overlay = TRUE)
visreg::visreg(bar[[3]], xvar = "mean_QDS_richness", by = "region", overlay = TRUE)

foo <- HDS %>%
  mutate(
    HDS_richness      = HDS_richness      / n_QDS,
    mean_QDS_richness = mean_QDS_richness / n_QDS,
    mul_turnover      = mul_turnover      / n_QDS
  )
bar <- list(
  lme4::lmer(HDS_richness ~ mean_QDS_turnover + (1 + mean_QDS_turnover |  region), foo),
  lme4::lmer(HDS_richness ~ mean_QDS_turnover + (1 + mean_QDS_turnover || region), foo),
  lme4::lmer(HDS_richness ~ mean_QDS_richness * mean_QDS_turnover + (1 + mean_QDS_turnover | region) + (1 + mean_QDS_richness | region), foo)
)
summary(bar[[1]])
visreg::visreg(bar[[1]], xvar = "mean_QDS_turnover", by = "region", overlay = TRUE)
visreg::visreg(bar[[2]], xvar = "mean_QDS_turnover", by = "region", overlay = TRUE)
visreg::visreg(bar[[3]], xvar = "mean_QDS_turnover", by = "region", overlay = TRUE)
visreg::visreg(bar[[3]], xvar = "mean_QDS_richness", by = "region", overlay = TRUE)

HDS %>% 
  dplyr::select(region, HDS_richness, mean_QDS_richness, n_QDS) %>%
  mutate(
    HDS_richness = HDS_richness / n_QDS,
    mean_QDS_richness = mean_QDS_richness / n_QDS
  ) %>%
  mutate(
    alpha = mean_QDS_richness / HDS_richness,
    beta = (HDS_richness - mean_QDS_richness) / HDS_richness
  ) %>%
  dplyr::select(region, HDS_richness, alpha, beta) %>%
  gather(partition, value, -region, -HDS_richness) %>%
  ggplot(aes(value, HDS_richness, colour = region)) +
    geom_point() +
    facet_grid(~partition)

HDS %>% dplyr::select(region, hdgc, HDS_richness, mean_QDS_richness, n_QDS) %>% mutate(HDS_richness = HDS_richness / n_QDS, mean_QDS_richness = mean_QDS_richness / n_QDS) %>% mutate(alpha = mean_QDS_richness / HDS_richness, beta = (HDS_richness - mean_QDS_richness) / HDS_richness) %>% dplyr::select(region, hdgc, HDS_richness, alpha, beta) %>% gather(partition, value, -region, -HDS_richness, -hdgc) %>% ggplot(aes(value, HDS_richness, colour = region, group = hdgc)) + geom_point() + geom_line()

HDS %>% dplyr::select(region, hdgc, HDS_richness, mean_QDS_richness, n_QDS) %>% mutate(HDS_richness = HDS_richness / n_QDS, mean_QDS_richness = mean_QDS_richness / n_QDS) %>% mutate(alpha = mean_QDS_richness / HDS_richness, beta = (HDS_richness - mean_QDS_richness) / HDS_richness) %>% dplyr::select(region, hdgc, HDS_richness, alpha, beta) %>% gather(partition, value, -region, -HDS_richness, -hdgc) %>% ggplot(aes(reorder(hdgc, desc(value)), value, fill = partition, colour = region)) + geom_col()

HDS %>% dplyr::select(region, hdgc, HDS_richness, mean_QDS_richness, n_QDS) %>% mutate(HDS_richness = HDS_richness / n_QDS, mean_QDS_richness = mean_QDS_richness / n_QDS) %>% mutate(alpha = mean_QDS_richness / HDS_richness, beta = (HDS_richness - mean_QDS_richness) / HDS_richness) %>% dplyr::select(region, hdgc, HDS_richness, alpha, beta) %>% ggplot(aes(reorder(hdgc, desc(beta)), beta, fill = region)) + geom_col()

HDS %>% dplyr::select(region, hdgc, HDS_richness, mean_QDS_richness, n_QDS) %>% mutate(HDS_richness = HDS_richness / n_QDS, mean_QDS_richness = mean_QDS_richness / n_QDS) %>% mutate(alpha = mean_QDS_richness / HDS_richness, beta = (HDS_richness - mean_QDS_richness) / HDS_richness) %>% dplyr::select(region, hdgc, HDS_richness, alpha, beta) %>% mutate(region = ifelse(region == "GCFR", 1, 0)) %>% {glm(region ~ beta, data = ., family = binomial)} %>% visreg::visreg(scale = "response", gg = TRUE) + scale_y_continuous(limits = c(0, 1), breaks = c(0, 1), labels = c("SWAFR", "GCFR"))

HDS %>% dplyr::select(region, hdgc, HDS_richness, mean_QDS_richness, n_QDS) %>% mutate(HDS_richness = HDS_richness / n_QDS, mean_QDS_richness = mean_QDS_richness / n_QDS) %>% mutate(alpha = mean_QDS_richness / HDS_richness, beta = (HDS_richness - mean_QDS_richness) / HDS_richness) %>% dplyr::select(region, hdgc, HDS_richness, alpha, beta) %>% mutate(beta_governed = beta > mean(beta)) %>% group_by(region) %>% summarise(n_HDS = n(), n_beta_governed = sum(beta_governed), prop_beta_governed = sum(beta_governed) / n())

```

## 2.1. Univariate comparisons

```{r, eval=FALSE}
ggplot(HDS, aes(HDS_richness, fill = region)) +
  geom_histogram(bins = 20, position = "dodge")
ggplot(HDS, aes(mul_turnover, fill = region)) +
  geom_histogram(bins = 20, position = "dodge")
ggplot(HDS, aes(mul_turnover, HDS_richness, colour = region)) +
  geom_smooth() +
  geom_point()
ggplot(HDS, aes(mul_turnover / n_QDS, HDS_richness / n_QDS, colour = region)) +
  geom_smooth() +#method = lm, formula = y ~ log(x)) +
  geom_point()
ggplot(HDS, aes(mean_QDS_richness, HDS_richness, colour = region)) +
  geom_smooth(method = lm) +
  geom_point()
ggplot(HDS, aes(mean_QDS_richness / n_QDS, HDS_richness / n_QDS, colour = region)) +
  geom_smooth(method = lm) +
  geom_point()
m <- lm(HDS_richness ~ mean_QDS_richness * mul_turnover + mean_QDS_richness * region + mul_turnover * region, HDS)
tidy(m)
visreg::visreg(m, xvar = "mean_QDS_richness", by = "region", cond = list(mul_turnover = 0.5), overlay = TRUE)
visreg::visreg(m, xvar = "mean_QDS_richness", by = "region", cond = list(region = "SWAFR"), overlay = TRUE)
```

# 3. Relating environmental heterogeneity to species richness & turnover

_Does heterogeneity explain differences in richness and turnover between the regions?_

...

```{r, eval=FALSE}
library(here)
source(here("analyses-May-2019/setup.R"))
HDS <- read_csv(here("outputs/QDS_data_cells.csv"))
QDS <- read_csv(here("outputs/EDS_data_cells.csv"))

# Log roughness values to match that PCAs were done on logged data
HDS[, str_which(names(HDS), "roughness")] %<>% log()
QDS[, str_which(names(QDS), "roughness")] %<>% log()

# (.)  Explore normality of data -----------------------------------------------

non_normal_vars <- HDS[, str_which(names(HDS), "(region|mean_value)")] %>%
  split(.$region) %>%
  map(dplyr::select, -region) %>%
  map(map, shapiro.test) %>%
  map(map_df, tidy, .id = "variable") %>%
  bind_rows(.id = "region") %>%
  as_tibble() %>%
  dplyr::select(-statistic, -method) %>%
  mutate(sig = p.value <= 0.05) %>%
  filter(sig)

HDS[, str_which(names(HDS), "(region|mean_value)")] %>%
  split(.$region) %>%
  map(dplyr::select, -region) %>%
  map(map, log) %>%  # !!!
  map(map, shapiro.test) %>%
  map(map_df, tidy, .id = "variable") %>%
  bind_rows(.id = "region") %>%
  as_tibble() %>%
  dplyr::select(-statistic, -method) %>%
  mutate(sig = p.value <= 0.05) %>%
  filter(sig)

# Conclusion: Logging can't solve everything!

# (a) Separate-regions models with combinations of variables -------------------

# .... HDS ---------------------------------------------------------------------

# ........ GCFR ----------------------------------------------------------------

GCFR_HDS <- filter(HDS, region == "GCFR")

predictor_names <- HDS %>%
  {names(.)[str_which(names(.), "(roughness|mean_value)")]} %>%
  paste(collapse = " + ")

m_all_richness <- lm(glue("HDS_richness ~ {predictor_names}"), GCFR_HDS)
m_all_turnover <- lm(glue("mul_turnover ~ {predictor_names}"), GCFR_HDS)
summary(m_all_richness)
summary(m_all_turnover)

m_all_richness_step <- step(m_all_richness)
m_all_turnover_step <- step(m_all_turnover)
summary(m_all_richness_step)
summary(m_all_turnover_step)

# PC1 only model
m_PC1_richness <- lm(HDS_richness ~ PC1, GCFR_HDS)
m_PC1_turnover <- lm(mul_turnover ~ PC1, GCFR_HDS)
summary(m_PC1_richness)
summary(m_PC1_turnover)
visreg::visreg(m_PC1_richness)
visreg::visreg(m_PC1_turnover)

# ........ SWAFR ---------------------------------------------------------------

SWAFR_HDS <- filter(HDS, region == "SWAFR")

predictor_names <- HDS %>%
  {names(.)[str_which(names(.), "(roughness|mean_value)")]} %>%
  paste(collapse = " + ")

m_all_richness <- lm(glue("HDS_richness ~ {predictor_names}"), SWAFR_HDS)
m_all_turnover <- lm(glue("mul_turnover ~ {predictor_names}"), SWAFR_HDS)
summary(m_all_richness)
summary(m_all_turnover)

m_all_richness_step <- step(m_all_richness)
m_all_turnover_step <- step(m_all_turnover)
summary(m_all_step)
summary(m_all_turnover_step)

# PC1 only model
m_PC1_richness <- lm(HDS_richness ~ PC1, SWAFR_HDS)
m_PC1_turnover <- lm(mul_turnover ~ PC1, SWAFR_HDS)
summary(m_PC1_richness)
summary(m_PC1_turnover)
visreg::visreg(m_PC1_richness)
visreg::visreg(m_PC1_turnover)

# .... QDS ---------------------------------------------------------------------

# ........ GCFR ----------------------------------------------------------------

GCFR_QDS <- filter(QDS, region == "GCFR")

predictor_names <- QDS %>%
  {names(.)[str_which(names(.), "(roughness|mean_value)")]} %>%
  paste(collapse = " + ")

m_all <- lm(glue("QDS_richness ~ {predictor_names}"), GCFR_QDS)
summary(m_all)

m_all_step <- step(m_all)
summary(m_all_step)

# PC1 only model
m_PC1 <- lm(QDS_richness ~ PC1, GCFR_QDS)
summary(m_PC1)
visreg::visreg(m_PC1)

# ........ SWAFR ---------------------------------------------------------------

SWAFR_QDS <- filter(QDS, region == "SWAFR")

predictor_names <- QDS %>%
  {names(.)[str_which(names(.), "(roughness|mean_value)")]} %>%
  paste(collapse = " + ")

m_all <- lm(glue("QDS_richness ~ {predictor_names}"), SWAFR_QDS)
summary(m_all)

m_all_step <- step(m_all)
summary(m_all_step)

# PC1 only model
m_PC1 <- lm(QDS_richness ~ PC1, SWAFR_QDS)
summary(m_PC1)
visreg::visreg(m_PC1)

# (b) Combined-regions models with individual variables ------------------------

# .... HDS ---------------------------------------------------------------------

# ........ Richness ------------------------------------------------------------

predictor_names <- names(HDS)[
  str_which(names(HDS), "(roughness|mean_value)")
]

HDS_richness_models_no_region <- predictor_names %>%
  map(~lm(glue("HDS_richness ~ {.x}"), HDS)) %>%
  set_names(predictor_names) %>%
  {tibble(predictor = names(.), model = .)} %>%
  mutate(
    slope_p_value = map_dbl(model, ~tidy(.x)$p.value[[2]]),
    r_squared     = map_dbl(model, ~glance(.x)$r.squared),
    slope_sig     = ifelse(slope_p_value <= 0.05, "*", ""),
    plot          = map(model, visreg::visreg, gg = TRUE)
  )
HDS_richness_models_add_region <- predictor_names %>%
  map(~lm(glue("HDS_richness ~ {.x} + region"), HDS)) %>%
  set_names(predictor_names) %>%
  {tibble(predictor = names(.), model = .)} %>%
  mutate(
    slope_p_value  = map_dbl(model, ~tidy(.x)$p.value[[2]]),
    region_p_value = map_dbl(model, ~tidy(.x)$p.value[[3]]),
    r_squared      = map_dbl(model, ~glance(.x)$r.squared),
    slope_sig      = ifelse(slope_p_value  <= 0.05, "*", ""),
    region_sig     = ifelse(region_p_value <= 0.05, "*", ""),
    plot           = map(model, visreg::visreg, gg = TRUE)
  )
HDS_richness_models_int_region <- predictor_names %>%
  map(~lm(glue("HDS_richness ~ {.x} * region"), HDS)) %>%
  set_names(predictor_names) %>%
  {tibble(predictor = names(.), model = .)} %>%
  mutate(
    #model_tidy     = map(model, tidy),
    #foo            = map_chr(map(model_tidy, "term"), paste, collapse = ", ")
    slope_p_value  = map_dbl(model, ~tidy(.x)$p.value[[2]]),
    region_p_value = map_dbl(model, ~tidy(.x)$p.value[[3]]),
    int_p_value    = map_dbl(model, ~tidy(.x)$p.value[[4]]),
    r_squared      = map_dbl(model, ~glance(.x)$r.squared),
    slope_sig      = ifelse(slope_p_value  <= 0.05, "*", ""),
    region_sig     = ifelse(region_p_value <= 0.05, "*", ""),
    int_sig        = ifelse(int_p_value    <= 0.05, "*", ""),
    plot           = map2(model, predictor,
                       ~ visreg::visreg(.x,
                         xvar = .y,
                         by = "region",
                         overlay = TRUE,
                         gg = TRUE
                       )
                     )
  )

cowplot::plot_grid(plotlist = HDS_richness_models_no_region$plot)
cowplot::plot_grid(plotlist = HDS_richness_models_add_region$plot)
cowplot::plot_grid(plotlist = HDS_richness_models_int_region$plot)

# ............ PC1 only model --------------------------------------------------

# Richness

m1 <- lm(HDS_richness ~ PC1,          HDS)
m2 <- lm(HDS_richness ~ PC1 + region, HDS)
m3 <- lm(HDS_richness ~ PC1 : region, HDS)
m4 <- lm(HDS_richness ~ PC1 * region, HDS)

AIC(m1, m2, m3, m4)

visreg::visreg(m1)
visreg::visreg(m2, xvar = "PC1", by = "region", overlay = TRUE)
visreg::visreg(m3, xvar = "PC1", by = "region", overlay = TRUE)
visreg::visreg(m4, xvar = "PC1", by = "region", overlay = TRUE)

tidy(m1)
glance(m1)

# Richness (QDS)

m1 <- lm(QDS_richness ~ PC1,          QDS)
m2 <- lm(QDS_richness ~ PC1 + region, QDS)
m3 <- lm(QDS_richness ~ PC1 : region, QDS)
m4 <- lm(QDS_richness ~ PC1 * region, QDS)

AIC(m1, m2, m3, m4)

visreg::visreg(m1)
visreg::visreg(m2, xvar = "PC1", by = "region", overlay = TRUE)
visreg::visreg(m3, xvar = "PC1", by = "region", overlay = TRUE)
visreg::visreg(m4, xvar = "PC1", by = "region", overlay = TRUE)

tidy(m1)
glance(m1)

# Turnover

m1 <- lm(mul_turnover ~ PC1,          HDS)
m2 <- lm(mul_turnover ~ PC1 + region, HDS)
m3 <- lm(mul_turnover ~ PC1 : region, HDS)
m4 <- lm(mul_turnover ~ PC1 * region, filter(HDS, n_QDS == 4))
m5 <- lm(mul_turnover ~ PC1 * region + n_QDS, HDS) # uh oh!

AIC(m1, m2, m3, m4)

visreg::visreg(m1)
visreg::visreg(m2, xvar = "PC1", by = "region", overlay = TRUE)
visreg::visreg(m3, xvar = "PC1", by = "region", overlay = TRUE)
visreg::visreg(m4, xvar = "PC1", by = "region", overlay = TRUE)
# !!!!!!

tidy(m4)
glance(m4)

# (c) Combined-regions models with combinations of variables -------------------

# TODO

m_all <- lm(
  HDS_richness ~
    Elevation_mean_value + Elevation_roughness +
    MAP_mean_value       + MAP_roughness +
    NDVI_mean_value      + NDVI_roughness +
    PDQ_mean_value       + PDQ_roughness +
    pH_mean_value        + pH_roughness +
    Soil.C_mean_value    + Soil.C_roughness +
    Surface.T_mean_value + Surface.T_roughness,
  HDS
)
summary(m_all)
m_all_step <- step(m_all)
summary(m_all_step)

m_all_int <- lm(
  HDS_richness ~
    Elevation_mean_value          + Elevation_roughness +
    MAP_mean_value                + MAP_roughness +
    NDVI_mean_value               + NDVI_roughness +
    PDQ_mean_value                + PDQ_roughness +
    pH_mean_value                 + pH_roughness +
    Soil.C_mean_value             + Soil.C_roughness +
    Surface.T_mean_value          + Surface.T_roughness +
    Elevation_mean_value : region + Elevation_roughness : region +
    MAP_mean_value       : region + MAP_roughness       : region +
    NDVI_mean_value      : region + NDVI_roughness      : region +
    PDQ_mean_value       : region + PDQ_roughness       : region +
    pH_mean_value        : region + pH_roughness        : region +
    Soil.C_mean_value    : region + Soil.C_roughness    : region +
    Surface.T_mean_value : region + Surface.T_roughness : region,
  HDS
)
m_all_int2 <- lm(
  QDS_richness ~
    Elevation_mean_value          + Elevation_roughness +
    MAP_mean_value                + MAP_roughness +
    NDVI_mean_value               + NDVI_roughness +
    PDQ_mean_value                + PDQ_roughness +
    pH_mean_value                 + pH_roughness +
    Soil.C_mean_value             + Soil.C_roughness +
    Surface.T_mean_value          + Surface.T_roughness +
    Elevation_mean_value : region + Elevation_roughness : region +
    MAP_mean_value       : region + MAP_roughness       : region +
    NDVI_mean_value      : region + NDVI_roughness      : region +
    PDQ_mean_value       : region + PDQ_roughness       : region +
    pH_mean_value        : region + pH_roughness        : region +
    Soil.C_mean_value    : region + Soil.C_roughness    : region +
    Surface.T_mean_value : region + Surface.T_roughness : region,
  QDS
)
summary(m_all_int)
summary(m_all_int2)
m_all_int_step <- step(m_all_int)
m_all_int_step2 <- step(m_all_int2)
summary(m_all_int_step)
summary(m_all_int_step2)
non_sigs <- m_all_int_step %>%
  tidy() %>%
  filter(p.value > 0.05, term != "(Intercept)") %>%
  pull(term) %>%
  paste(collapse = " - ") %>%
  {paste("-", .)}

m_all_int_step_manual <- update(
  m_all_int_step,
  as.formula(paste("~ .", non_sigs))
)
summary(m_all_int_step_manual)
non_sigs <- m_all_int_step_manual %>%
  tidy() %>%
  filter(p.value > 0.05, term != "(Intercept)") %>%
  pull(term) %>%
  paste(collapse = " - ") %>%
  {paste("-", .)}
m_all_int_step_manual2 <- update(
  m_all_int_step_manual,
  as.formula(paste("~ .", non_sigs))
)
summary(m_all_int_step_manual2)

AIC(m_all, m_all_step, m_all_int, m_all_int_step)

foo <- tibble(
  fit    = m_all_int_step$fitted.values,
  obs    = HDS$HDS_richness,
  region = HDS$region
)
ggplot(foo, aes(obs, fit)) +
  geom_smooth(method = lm, colour = "black") +
  geom_point(aes(colour = region))
#plot(m_all_int_step)

foo2 <- tibble(
  fit    = m_all_int_step2$fitted.values,
  obs    = QDS$QDS_richness,
  region = QDS$region
)
ggplot(foo2, aes(obs, fit)) +
  geom_smooth(method = lm, colour = "black") +
  geom_point(aes(colour = region), alpha = 0.25)
#plot(m_all_int_step2)

# (*) Plots --------------------------------------------------------------------

ggplot(HDS, aes(PC1, HDS_richness)) +
  geom_point(aes(colour = region)) +
  geom_smooth(method = lm, colour = "black")
ggplot(QDS, aes(PC1, QDS_richness)) +
  geom_point(aes(colour = region)) +
  geom_smooth(method = lm, colour = "black")
m <- lm(HDS_richness ~ PC1, HDS)
#plot(m)
ggplot(HDS, aes(Elevation_mean_value, HDS_richness)) +
  geom_point(aes(colour = region)) +
  geom_smooth(method = lm, colour = "black")
ggplot(HDS, aes(Elevation_roughness, HDS_richness)) +
  geom_point(aes(colour = region)) +
  geom_smooth(method = lm, colour = "black")

ggplot(HDS, aes(PC1, Elevation_roughness, colour = region)) +
  geom_point()
ggplot(HDS, aes(PC2, Elevation_roughness, colour = region)) +
  geom_point()

ggplot(QDS, aes(lon, lat, colour = PC1)) +
  geom_point(size = 3) +
  facet_grid(~region, scales = "free_x") +
  scale_colour_viridis_c()

ggplot(HDS, aes(lon, lat, colour = PC1)) +
  geom_point(size = 3) +
  facet_wrap(~region, scales = "free") +
  scale_colour_viridis_c()
ggplot(HDS, aes(lon, lat, colour = PC2)) +
  geom_point(size = 3) +
  facet_wrap(~region, scales = "free")

# (...) PCA biplots again ------------------------------------------------------

HDS_PCA      <- read_rds(here("outputs/QDS_roughness_cells_PCA.RDS"))
HDS_PCA_data <- read_csv(here("outputs/QDS_roughness_cells_prepped.csv"))
QDS_PCA      <- read_rds(here("outputs/EDS_roughness_cells_PCA.RDS"))
QDS_PCA_data <- read_csv(here("outputs/EDS_roughness_cells_prepped.csv"))

# Log to match PCA
HDS_PCA_data[, -c(1, 2)] %<>% log()
QDS_PCA_data[, -c(1, 2)] %<>% log()

autoplot(HDS_PCA,
  data            = HDS_PCA_data,
  colour          = "region",
  loadings        = TRUE,
  loadings.colour = "blue",
  loadings.label  = TRUE
)
autoplot(QDS_PCA,
  data            = QDS_PCA_data,
  colour          = "region",
  loadings        = TRUE,
  loadings.colour = "blue",
  loadings.label  = TRUE
)

HDS %>%
  filter(n_QDS == 4) %>%
  dplyr::select(region, PC1, PC2) %>%
  group_by(region) %>%
  summarise_all(.funs = list(mean = mean, sd = sd)) %>%
  mutate(
    PC1_upp = PC1_mean + PC1_sd,
    PC1_low = PC1_mean - PC1_sd,
    PC2_upp = PC2_mean + PC2_sd,
    PC2_low = PC2_mean - PC2_sd
  ) %>%
  ggplot(aes(PC1_mean, PC2_mean, colour = region)) +
    geom_hline(yintercept = 0, lty = "dashed", colour = "grey25") +
    geom_vline(xintercept = 0, lty = "dashed", colour = "grey25") +
    geom_point() +
    geom_errorbar( aes(ymin = PC2_low, ymax = PC2_upp), width  = 0) +
    geom_errorbarh(aes(xmin = PC1_low, xmax = PC1_upp), height = 0) +
    geom_point(
      data    = filter(HDS, n_QDS == 4),
      mapping = aes(PC1, PC2, colour = region),
      alpha   = 0.5
    ) +
    theme_minimal()

QDS %>%
  filter(n_EDS == 4) %>%
  dplyr::select(region, PC1, PC2) %>%
  group_by(region) %>%
  summarise_all(.funs = list(mean = mean, sd = sd)) %>%
  mutate(
    PC1_upp = PC1_mean + PC1_sd,
    PC1_low = PC1_mean - PC1_sd,
    PC2_upp = PC2_mean + PC2_sd,
    PC2_low = PC2_mean - PC2_sd
  ) %>%
  ggplot(aes(PC1_mean, PC2_mean, colour = region)) +
    geom_hline(yintercept = 0, lty = "dashed", colour = "grey25") +
    geom_vline(xintercept = 0, lty = "dashed", colour = "grey25") +
    geom_point() +
    geom_errorbar( aes(ymin = PC2_low, ymax = PC2_upp), width  = 0) +
    geom_errorbarh(aes(xmin = PC1_low, xmax = PC1_upp), height = 0) +
    geom_point(
      data    = filter(QDS, n_EDS == 4),
      mapping = aes(PC1, PC2, colour = region),
      alpha   = 0.25
    ) +
    theme_minimal()

ggplot(HDS, aes(PC1, PC2, colour = PC2 > 0)) +
  geom_point()

HDS %>%
  split(.$region) %>%
  map(~.x %$% table(PC2 > 0, PC1 > 0))

my_PCA_plot <- function(data) {
  get_lim <- function(x) {
    lim <- ceiling(max(x))
    c(-lim, lim)
  }
  plot_xlim <- get_lim(data$PC1)
  plot_ylim <- get_lim(data$PC2)
  no_legend_no_grid <- theme(
    legend.position  = "none",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
  white_rect <- grid::grid.rect(gp = grid::gpar(col = "white"))

  PC1_histograms <- ggplot(data, aes(PC1, fill = region)) +
    geom_histogram(bins = 20, position = "dodge") +
    xlim(plot_xlim) +
    theme_minimal() +
    theme(
      axis.title.x       = element_blank(),
      axis.text.x        = element_blank(),
      axis.text.y        = element_text(angle = 90),
      axis.line.x.bottom = element_blank(),
      axis.line.x.top    = element_blank(),
      axis.line.y.right  = element_blank()
    ) +
    no_legend_no_grid
  PC2_histograms <- ggplot(data, aes(PC2, fill = region)) +
    geom_histogram(bins = 20, position = "dodge") +
    xlim(plot_ylim) +
    coord_flip() +
    theme_minimal() +
    theme(
      axis.title.y       = element_blank(),
      axis.text.y        = element_blank(),
      axis.line.y.right  = element_blank(),
      axis.line.y.left   = element_blank(),
      axis.line.x.top    = element_blank()
    ) +
    no_legend_no_grid

  PCA_biplot <- ggplot(data, aes(PC1, PC2, colour = region)) +
    geom_hline(yintercept = 0, lty = "dashed", colour = "grey25") +
    geom_vline(xintercept = 0, lty = "dashed", colour = "grey25") +
    geom_point() +
    lims(x = plot_xlim, y = plot_ylim) +
    theme_bw() +
    theme(axis.text.y = element_text(angle = 90)) +
    no_legend_no_grid

  cowplot::plot_grid(
    PC1_histograms, white_rect,
    PCA_biplot,      PC2_histograms,
    ncol = 2,
    rel_widths = c(4, 1), rel_heights = c(1, 4)
  )
}
foo <- my_PCA_plot(HDS)
foo
PC1_histograms <- ggplot(QDS, aes(PC1, fill = region)) +
  xlim(-5, 5) +
  geom_histogram(bins = 20, position = "dodge") +
  theme_minimal() +
  theme(legend.position = "none", axis.title.x = element_blank(),
                                  axis.text.x = element_blank(),
                                  axis.text.y = element_text(angle = 90),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
PC2_histograms <- ggplot(QDS, aes(PC2, fill = region)) +
  xlim(-5, 5) +
  geom_histogram(bins = 20, position = "dodge") +
  coord_flip() +
  theme_minimal() +
  theme(legend.position = "none", axis.title.y = element_blank(),
                                  axis.text.y = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
PC_biplot <- ggplot(QDS, aes(PC1, PC2, colour = region)) +
  lims(x = c(-5, 5), y = c(-5, 5)) +
  geom_hline(yintercept = 0, lty = "dashed", colour = "grey25") +
  geom_vline(xintercept = 0, lty = "dashed", colour = "grey25") +
  geom_point() +
  theme_bw() +
  theme(legend.position = "none", axis.text.y = element_text(angle = 90),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

white_rect <- grid::grid.rect(gp = grid::gpar(col = "white"))
cowplot::plot_grid(
  PC1_histograms, white_rect,
  PC_biplot,      PC2_histograms,
  ncol = 2,
  rel_widths = c(4, 1), rel_heights = c(1, 4)
)

PC1_histograms <- ggplot(HDS, aes(PC1, fill = region)) +
  #xlim(-5, 5) +
  geom_histogram(bins = 20, position = "dodge") +
  theme_minimal() +
  theme(legend.position = "none", axis.title.x = element_blank(),
                                  axis.text.x = element_blank(),
                                  axis.title.y = element_blank(),
                                  axis.text.y = element_blank(),
                                  #axis.text.y = element_text(angle = 90),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
PC2_histograms <- ggplot(HDS, aes(PC2, fill = region)) +
  #xlim(-5, 5) +
  geom_histogram(bins = 20, position = "dodge") +
  coord_flip() +
  theme_minimal() +
  theme(legend.position = "none", axis.title.y = element_blank(),
                                  axis.text.y = element_blank(),
                                  axis.title.x = element_blank(),
                                  axis.text.x = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
PC_biplot <- ggplot(HDS, aes(PC1, PC2, colour = region)) +
  #lims(x = c(-5, 5), y = c(-5, 5)) +
  geom_hline(yintercept = 0, lty = "dashed", colour = "grey25") +
  geom_vline(xintercept = 0, lty = "dashed", colour = "grey25") +
  geom_point() +
  theme_bw() +
  theme(legend.position = "none", axis.text.y = element_text(angle = 90),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

white_rect <- grid::grid.rect(gp = grid::gpar(col = "white"))
cowplot::plot_grid(
  PC1_histograms, white_rect,
  PC_biplot,      PC2_histograms,
  ncol = 2,
  rel_widths = c(4, 1), rel_heights = c(1, 4)
)

all_PCA_data <- rbind(
  cbind(scale = "HDS", HDS_PCA_data[, -2]),
  cbind(scale = "QDS", QDS_PCA_data[, -2])
)

foo <- prcomp(all_PCA_data[, -c(1, 2)], scale. = TRUE)
if (all(foo$rotation[, 1] <= 0)) {
  foo$rotation[, 1] %<>% multiply_by(-1)
  foo$x[, 1]        %<>% multiply_by(-1)
}
autoplot(foo, data = unite(all_PCA_data, region_scale, region, scale), colour = "region_scale", alpha = 0.25)
```

## 3.1. Separate-regions models with combinations of variables

## 3.2. Combined-regions models with individual variables

## 3.3. Combined-regions models with combinations of variables
