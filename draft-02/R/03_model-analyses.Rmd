# 3. Relating heterogeneity to species richness & turnover

Does heterogeneity explain differences in richness and turnover between the regions?

<!--
Environmental “roughness” in both regions was calculated, in moving 3 x 3 cell windows, as the average absolute difference between cells and their (usually) 8 neighbours. Alternatively, for a focal cell x∗, the roughness is based on x1,x2,...,xi,...,x8 neighbour cells as:
-->

Here I fit various linear regressions of richness and turnover as functions of environmental heterogeneity across the two regions. The richness and turnover measures used are the same as in the previous section, while the environmental heterogeneity was recalculated in the same grid-wise fashion as the richness and turnover measures. These analyses were carried out at both the HDS- and QDS-scales, insofar as species occurrence data from GBIF is only accurate to the QDS-scale. These analyses were only carried out on HDS-scale data for HDS-cells that contained four QDS-cells, and similarly for QDS-scale data for QDS-cells that contained four EDS-cells.

Environmental "roughness" here was calculated for each HDS- and QDS-cell in both regions as the mean of each consituent QDS- and EDS-cell's mean absolute difference in environmental conditions from the other three cells within that HDS- or QDS-cell.

In other words, roughness was calculated by first calculating the average absolute-difference in environmental values between each QDS and it's three neighbours in a given HDS. Then, these four values (assuming four QDS in an HDS) are averaged. This roughness index is presented mathematically below. This index allows each of the four values to be similarly independent, and thus more sutiable for our averaging and analyses, as opposed to if it were simly the direct average of pairwise differences [expand?].

$$
  Roughness_{cellular}(\{ x_1, x_2, x_3, x_4 \}) =
    \frac{1}{4} \sum_i f(x_i) =
    \frac{1}{4} \sum_i \left(
      \frac{1}{3} \sum_{j \neq i} |x_i - x_j|
    \right)
$$

In R, this is implemented this as follows:

```
roughness_cellular <- function(x) {
  out <- vector(mode = "numeric", length = length(x))
  for (i in seq_along(x)) {
    out[[i]] <- mean(abs(x[i] - x[-i]))
  }
  mean(out)
}
```

<!--
Alternatves:

```
roughness_cells <- function(x) {
  mean(c(
    mean(abs(x[1] - x[-1])),
    mean(abs(x[2] - x[-2])),
    mean(abs(x[3] - x[-3])),
    mean(abs(x[4] - x[-4]))
  ))
}
```

```
mean_diff <- function(x, i) {
  mean(abs(x[i] - x[-i]))
}
roughness_cells <- function(x) {
  mean(c(
    mean_diff(x, 1),
    mean_diff(x, 2),
    mean_diff(x, 3),
    mean_diff(x, 4)
  ))
}
```

```
mean_diff <- function(x, i) {
  mean(abs(x[i] - x[-i]))
}
roughness_cells <- function(x) {
  x %>%
    seq_along() %>%
    imap_dbl(function(x, i) mean_diff(x, i)) %>%
    mean()
}
```
-->

```{r tidy-cellular-data, include=FALSE}
# log(x + 1) & scale roughness values to match PCAs were done on logged data
HDS[, str_which(names(HDS), "roughness")] %<>%
  log1p() %>%
  scale()
QDS[, str_which(names(QDS), "roughness")] %<>%
  log1p() %>%
  scale()

# Make regin-specific subsets for modelling below
GCFR_HDS  <- filter(HDS, region == "GCFR")
GCFR_QDS  <- filter(QDS, region == "GCFR")
SWAFR_HDS <- filter(HDS, region == "SWAFR")
SWAFR_QDS <- filter(QDS, region == "SWAFR")
```

```{r explore-normality, include=FALSE}
## Explore normality of data
#
#non_normal_vars <- HDS[, str_which(names(HDS), "(region|mean_value)")] %>%
#  split(.$region) %>%
#  map(dplyr::select, -region) %>%
#  map(map, shapiro.test) %>%
#  map(map_df, tidy, .id = "variable") %>%
#  bind_rows(.id = "region") %>%
#  as_tibble() %>%
#  dplyr::select(-statistic, -method) %>%
#  mutate(sig = p.value <= 0.05) %>%
#  filter(sig)
#
#HDS[, str_which(names(HDS), "(region|mean_value)")] %>%
#  split(.$region) %>%
#  map(dplyr::select, -region) %>%
#  map(map, log) %>%  # !!!
#  map(map, shapiro.test) %>%
#  map(map_df, tidy, .id = "variable") %>%
#  bind_rows(.id = "region") %>%
#  as_tibble() %>%
#  dplyr::select(-statistic, -method) %>%
#  mutate(sig = p.value <= 0.05) %>%
#  filter(sig)
#
## Conclusion: Logging can't solve everything!
```

The models I fit here are as follows:

Response                              | Variables | Region term      
--------------------------------------|-----------|----------------
$S_{\mathrm{HDS}}$                    | Separate  | Separate
"                                     | "         | None        
"                                     | "         | Additive    
"                                     | "         | Interaction 
"                                     | AIC-set   | Separate
"                                     | "         | None        
"                                     | "         | Additive    
"                                     | "         | Interaction 
"                                     | PC1       | Separate
"                                     | "         | None        
"                                     | "         | Additive    
"                                     | "         | Interaction 
                                      |           | 
$S_{\mathrm{QDS}}$                    | Separate  | Separate
"                                     | "         | None        
"                                     | "         | Additive    
"                                     | "         | Interaction 
"                                     | AIC-set   | Separate
"                                     | "         | None        
"                                     | "         | Additive    
"                                     | "         | Interaction 
"                                     | PC1       | Separate
"                                     | "         | None        
"                                     | "         | Additive    
"                                     | "         | Interaction 
                                      |           | 
$T_{\mathrm{HDS}} / S_{\mathrm{HDS}}$ | Separate  | Separate
"                                     | "         | None        
"                                     | "         | Additive    
"                                     | "         | Interaction 
"                                     | AIC-set   | Separate
"                                     | "         | None        
"                                     | "         | Additive    
"                                     | "         | Interaction 
"                                     | PC1       | Separate
"                                     | "         | None        
"                                     | "         | Additive    
"                                     | "         | Interaction 

## 3.1. Separate environmental variable models

#### 3.1.1. With $S_{\mathrm{HDS}}$ as the response

```{r fit-combined-region-HDS-richness-models}
predictor_names <- names(HDS)[
  str_which(names(HDS), "(roughness|PC1)")
]

HDS_richness_models_no_region <- predictor_names %>%
  map(~lm(glue("HDS_richness ~ {.x}"), HDS)) %>%
  set_names(predictor_names) %>%
  {tibble(predictor = names(.), model = .)} %>%
  mutate(
    slope_p_value = map_dbl(model, ~tidy(.x)$p.value[[2]]),
    r_squared     = map_dbl(model, ~glance(.x)$r.squared),
    slope_sig     = ifelse(slope_p_value <= 0.05, "*", "")
  )
HDS_richness_models_add_region <- predictor_names %>%
  map(~lm(glue("HDS_richness ~ {.x} + region"), HDS)) %>%
  set_names(predictor_names) %>%
  {tibble(predictor = names(.), model = .)} %>%
  mutate(
    slope_p_value  = map_dbl(model, ~tidy(.x)$p.value[[2]]),
    region_p_value = map_dbl(model, ~tidy(.x)$p.value[[3]]),
    r_squared      = map_dbl(model, ~glance(.x)$r.squared),
    slope_sig      = ifelse(slope_p_value  <= 0.05, "*", ""),
    region_sig     = ifelse(region_p_value <= 0.05, "*", "")
  )
HDS_richness_models_int_region <- predictor_names %>%
  map(~lm(glue("HDS_richness ~ {.x} * region"), HDS)) %>%
  set_names(predictor_names) %>%
  {tibble(predictor = names(.), model = .)} %>%
  mutate(
    slope_p_value  = map_dbl(model, ~tidy(.x)$p.value[[2]]),
    region_p_value = map_dbl(model, ~tidy(.x)$p.value[[3]]),
    int_p_value    = map_dbl(model, ~tidy(.x)$p.value[[4]]),
    r_squared      = map_dbl(model, ~glance(.x)$r.squared),
    slope_sig      = ifelse(slope_p_value  <= 0.05, "*", ""),
    region_sig     = ifelse(region_p_value <= 0.05, "*", ""),
    int_sig        = ifelse(int_p_value    <= 0.05, "*", "")
  )

HDS_richness_models_no_region[c(
  "region_p_value", "region_sig",
  "int_p_value",    "int_sig"
)] <- NA
HDS_richness_models_add_region[c(
  "int_p_value",    "int_sig"
)] <- NA
HDS_richness_models <- as_tibble(rbind(
  cbind(region_term = "none", HDS_richness_models_no_region),
  cbind(region_term = "add",  HDS_richness_models_add_region),
  cbind(region_term = "int",  HDS_richness_models_int_region)
))
```

```{r compare-and-print-combined-region-HDS-richness-models}
# Get AICs etc.
HDS_richness_models_summary <- HDS_richness_models %>%
  group_by(predictor) %>%
  mutate(aic = map_dbl(model, AIC)) %>%
  mutate(
    model_rank = as.numeric(region_term),
    delta_aic = aic - min(aic),
    # Choose the "best" ^ "simplest" model
    best_model = model_rank == min(model_rank[delta_aic < 2])
  ) %>%
  ungroup()

# Make pretty
HDS_richness_models_summary_printable <- HDS_richness_models_summary %>%
  mutate(
    predictor = predictor %>%
      str_remove("_roughness") %>%
      str_replace_all("\\.", " ") %>%
      factor(levels = c(var_names, "PC1")),
    region_term = case_when(
      region_term == "none" ~ "None",
      region_term == "add"  ~ "Additive",
      region_term == "int"  ~ "Interaction",
    ),
    best_model = ifelse(best_model, "*", " ")
  ) %>%
  arrange(predictor) %>%
  mutate_at(c("slope_p_value", "region_p_value", "int_p_value"),
    ~ifelse(.x < 0.050, NaN, .x)  # recode significance as NaN...
  ) %>%
  mutate_if(is.numeric, ~ case_when(
    is.nan(.x) ~ "< 0.050",  # so that here is get's turned into text
    is.na(.x)  ~ " ",
    TRUE       ~ format(round(.x, digits = 3), nsmall = 3)
  )) %>%
  mutate_if(is.character, ~ ifelse(is.na(.x), " ", .x)) %>%
  dplyr::select(
    predictor, region_term, delta_aic, best_model,
    slope_p_value,
    region_p_value,
    int_p_value
  )

# Remove variable names after first mention in table
HDS_richness_models_summary_printable$predictor %<>% as.character()
for (pred in unique(HDS_richness_models_summary_printable$predictor)) {
  to_remove <- HDS_richness_models_summary_printable %$%
    which(predictor == pred)[-1]
  HDS_richness_models_summary_printable$predictor[to_remove] <- " "
}

knitr::kable(HDS_richness_models_summary_printable,
  caption = paste(
    "Results of separate simple linear regressions of $S_{\\mathrm{HDS}}$",
    "against environmental heterogeneity variables."
  ),
  col.names = c(
    "Environmental predictor", "Model", "$\\Delta AIC$", " ",
    "$P_{\\mathrm{slope}}$",
    "$P_{\\mathrm{region}}$",
    "$P_{\\mathrm{slope:region}}$"
  ),
  align = "llrcrrr"
)
```

```{r plot-combined-region-models-fits}
# TODO: neaten these plots
#HDS_richness_models_no_region$plot[c(2, 3, 5, 6, 8, 9)] %<>%
#  map(~ .x + theme(
#    axis.title.y = element_blank(),
#    axis.text.y  = element_blank(),
#    axis.ticks.y = element_blank()
#  ))
#HDS_richness_models_add_region$plot[c(2, 3, 5, 6, 8, 9)] %<>%
#  map(~ .x + theme(
#    axis.title.y = element_blank(),
#    axis.text.y  = element_blank(),
#    axis.ticks.y = element_blank()
#  ))
#HDS_richness_models_add_region$plot[c(1, 2, 4, 5, 7, 8)] %<>%
#  map(~ .x + theme(legend.position = "none"))
#HDS_richness_models_int_region$plot[c(2, 3, 5, 6, 8, 9)] %<>%
#  map(~ .x + theme(
#    axis.title.y = element_blank(),
#    axis.text.y  = element_blank(),
#    axis.ticks.y = element_blank()
#  ))
#HDS_richness_models_int_region$plot[c(1, 2, 4, 5, 7, 8)] %<>%
#  map(~ .x + theme(legend.position = "none"))
#
#plot_grid(plotlist = HDS_richness_models_no_region$plot)
#plot_grid(plotlist = HDS_richness_models_add_region$plot)
#plot_grid(plotlist = HDS_richness_models_int_region$plot)
```

#### 3.1.2. With $S_{\mathrm{QDS}}$ as the response

```{r fit-combined-region-QDS-richness-models}
predictor_names <- names(QDS)[
  str_which(names(QDS), "(roughness|PC1)")
]

QDS_richness_models_no_region <- predictor_names %>%
  map(~lm(glue("QDS_richness ~ {.x}"), QDS)) %>%
  set_names(predictor_names) %>%
  {tibble(predictor = names(.), model = .)} %>%
  mutate(
    slope_p_value = map_dbl(model, ~tidy(.x)$p.value[[2]]),
    r_squared     = map_dbl(model, ~glance(.x)$r.squared),
    slope_sig     = ifelse(slope_p_value <= 0.05, "*", "")
  )
QDS_richness_models_add_region <- predictor_names %>%
  map(~lm(glue("QDS_richness ~ {.x} + region"), QDS)) %>%
  set_names(predictor_names) %>%
  {tibble(predictor = names(.), model = .)} %>%
  mutate(
    slope_p_value  = map_dbl(model, ~tidy(.x)$p.value[[2]]),
    region_p_value = map_dbl(model, ~tidy(.x)$p.value[[3]]),
    r_squared      = map_dbl(model, ~glance(.x)$r.squared),
    slope_sig      = ifelse(slope_p_value  <= 0.05, "*", ""),
    region_sig     = ifelse(region_p_value <= 0.05, "*", "")
  )
QDS_richness_models_int_region <- predictor_names %>%
  map(~lm(glue("QDS_richness ~ {.x} * region"), QDS)) %>%
  set_names(predictor_names) %>%
  {tibble(predictor = names(.), model = .)} %>%
  mutate(
    slope_p_value  = map_dbl(model, ~tidy(.x)$p.value[[2]]),
    region_p_value = map_dbl(model, ~tidy(.x)$p.value[[3]]),
    int_p_value    = map_dbl(model, ~tidy(.x)$p.value[[4]]),
    r_squared      = map_dbl(model, ~glance(.x)$r.squared),
    slope_sig      = ifelse(slope_p_value  <= 0.05, "*", ""),
    region_sig     = ifelse(region_p_value <= 0.05, "*", ""),
    int_sig        = ifelse(int_p_value    <= 0.05, "*", "")
  )

QDS_richness_models_no_region[c(
  "region_p_value", "region_sig",
  "int_p_value",    "int_sig"
)] <- NA
QDS_richness_models_add_region[c(
  "int_p_value",    "int_sig"
)] <- NA
QDS_richness_models <- as_tibble(rbind(
  cbind(region_term = "none", QDS_richness_models_no_region),
  cbind(region_term = "add",  QDS_richness_models_add_region),
  cbind(region_term = "int",  QDS_richness_models_int_region)
))
```

```{r compare-and-print-combined-region-QDS-richness-models}
# Get AICs etc.
QDS_richness_models_summary <- QDS_richness_models %>%
  group_by(predictor) %>%
  mutate(aic = map_dbl(model, AIC)) %>%
  mutate(
    model_rank = as.numeric(region_term),
    delta_aic = aic - min(aic),
    # Choose the "best" ^ "simplest" model
    best_model = model_rank == min(model_rank[delta_aic < 2])
  ) %>%
  ungroup()

# Make pretty
QDS_richness_models_summary_printable <- QDS_richness_models_summary %>%
  mutate(
    predictor = predictor %>%
      str_remove("_roughness") %>%
      str_replace_all("\\.", " ") %>%
      factor(levels = c(var_names, "PC1")),
    region_term = case_when(
      region_term == "none" ~ "None",
      region_term == "add"  ~ "Additive",
      region_term == "int"  ~ "Interaction",
    ),
    best_model = ifelse(best_model, "*", " ")
  ) %>%
  arrange(predictor) %>%
  mutate_at(c("slope_p_value", "region_p_value", "int_p_value"),
    ~ifelse(.x < 0.050, NaN, .x)  # recode significance as NaN...
  ) %>%
  mutate_if(is.numeric, ~ case_when(
    is.nan(.x) ~ "< 0.050",  # so that here is get's turned into text
    is.na(.x)  ~ " ",
    TRUE       ~ format(round(.x, digits = 3), nsmall = 3)
  )) %>%
  mutate_if(is.character, ~ ifelse(is.na(.x), " ", .x)) %>%
  dplyr::select(
    predictor, region_term, delta_aic, best_model,
    slope_p_value,
    region_p_value,
    int_p_value
  )

# Remove variable names after first mention in table
QDS_richness_models_summary_printable$predictor %<>% as.character()
for (pred in unique(QDS_richness_models_summary_printable$predictor)) {
  to_remove <- QDS_richness_models_summary_printable %$%
    which(predictor == pred)[-1]
  QDS_richness_models_summary_printable$predictor[to_remove] <- " "
}

knitr::kable(QDS_richness_models_summary_printable,
  caption = paste(
    "Results of separate simple linear regressions of $S_{\\mathrm{QDS}}$",
    "against environmental heterogeneity variables."
  ),
  col.names = c(
    "Environmental predictor", "Model", "$\\Delta AIC$", " ",
    "$P_{\\mathrm{slope}}$",
    "$P_{\\mathrm{region}}$",
    "$P_{\\mathrm{slope:region}}$"
  ),
  align = "llrcrrr"
)
```

#### 3.2.3. With $T_{\mathrm{QDS}} / S_{\mathrm{HDS}}$ as the response

```{r fit-combined-region-add-turnover-prop-models}
predictor_names <- names(HDS)[
  str_which(names(HDS), "(roughness|PC1)")
]

add_turnover_prop_models_no_region <- predictor_names %>%
  map(~lm(glue("add_turnover_prop ~ {.x}"), HDS)) %>%
  set_names(predictor_names) %>%
  {tibble(predictor = names(.), model = .)} %>%
  mutate(
    slope_p_value = map_dbl(model, ~tidy(.x)$p.value[[2]]),
    r_squared     = map_dbl(model, ~glance(.x)$r.squared),
    slope_sig     = ifelse(slope_p_value <= 0.05, "*", "")
  )
add_turnover_prop_models_add_region <- predictor_names %>%
  map(~lm(glue("add_turnover_prop ~ {.x} + region"), HDS)) %>%
  set_names(predictor_names) %>%
  {tibble(predictor = names(.), model = .)} %>%
  mutate(
    slope_p_value  = map_dbl(model, ~tidy(.x)$p.value[[2]]),
    region_p_value = map_dbl(model, ~tidy(.x)$p.value[[3]]),
    r_squared      = map_dbl(model, ~glance(.x)$r.squared),
    slope_sig      = ifelse(slope_p_value  <= 0.05, "*", ""),
    region_sig     = ifelse(region_p_value <= 0.05, "*", "")
  )
add_turnover_prop_models_int_region <- predictor_names %>%
  map(~lm(glue("add_turnover_prop ~ {.x} * region"), HDS)) %>%
  set_names(predictor_names) %>%
  {tibble(predictor = names(.), model = .)} %>%
  mutate(
    slope_p_value  = map_dbl(model, ~tidy(.x)$p.value[[2]]),
    region_p_value = map_dbl(model, ~tidy(.x)$p.value[[3]]),
    int_p_value    = map_dbl(model, ~tidy(.x)$p.value[[4]]),
    r_squared      = map_dbl(model, ~glance(.x)$r.squared),
    slope_sig      = ifelse(slope_p_value  <= 0.05, "*", ""),
    region_sig     = ifelse(region_p_value <= 0.05, "*", ""),
    int_sig        = ifelse(int_p_value    <= 0.05, "*", "")
  )

add_turnover_prop_models_no_region[c(
  "region_p_value", "region_sig",
  "int_p_value",    "int_sig"
)] <- NA
add_turnover_prop_models_add_region[c(
  "int_p_value",    "int_sig"
)] <- NA
add_turnover_prop_models <- as_tibble(rbind(
  cbind(region_term = "none",add_turnover_prop_models_no_region),
  cbind(region_term = "add", add_turnover_prop_models_add_region),
  cbind(region_term = "int", add_turnover_prop_models_int_region)
))
```

```{r compare-and-print-combined-region-add-turnover-prop-models}
# Get AICs etc.
add_turnover_prop_models_summary <- add_turnover_prop_models %>%
  group_by(predictor) %>%
  mutate(aic = map_dbl(model, AIC)) %>%
  mutate(
    model_rank = as.numeric(region_term),
    delta_aic = aic - min(aic),
    # Choose the "best" ^ "simplest" model
    best_model = model_rank == min(model_rank[delta_aic < 2])
  ) %>%
  ungroup()

# Make pretty
add_turnover_prop_models_summary_printable <- add_turnover_prop_models_summary %>%
  mutate(
    predictor = predictor %>%
      str_remove("_roughness") %>%
      str_replace_all("\\.", " ") %>%
      factor(levels = c(var_names, "PC1")),
    region_term = case_when(
      region_term == "none" ~ "None",
      region_term == "add"  ~ "Additive",
      region_term == "int"  ~ "Interaction",
    ),
    best_model = ifelse(best_model, "*", " ")
  ) %>%
  arrange(predictor) %>%
  mutate_at(c("slope_p_value", "region_p_value", "int_p_value"),
    ~ifelse(.x < 0.050, NaN, .x)  # recode significance as NaN...
  ) %>%
  mutate_if(is.numeric, ~ case_when(
    is.nan(.x) ~ "< 0.050",  # so that here is get's turned into text
    is.na(.x)  ~ " ",
    TRUE       ~ format(round(.x, digits = 3), nsmall = 3)
  )) %>%
  mutate_if(is.character, ~ ifelse(is.na(.x), " ", .x)) %>%
  dplyr::select(
    predictor, region_term, delta_aic, best_model,
    slope_p_value,
    region_p_value,
    int_p_value
  )

# Remove variable names after first mention in table
add_turnover_prop_models_summary_printable$predictor %<>% as.character()
for (pred in unique(add_turnover_prop_models_summary_printable$predictor)) {
  to_remove <- add_turnover_prop_models_summary_printable %$%
    which(predictor == pred)[-1]
  add_turnover_prop_models_summary_printable$predictor[to_remove] <- " "
}
knitr::kable(add_turnover_prop_models_summary_printable,
  caption = paste(
    "Results of separate simple linear regressions of $T_{\\mathrm{QDS}} /",
    "S_{\\mathrm{HDS}}$ against environmental heterogeneity variables."
  ),
  col.names = c(
    "Environmental predictor", "Model", "$\\Delta AIC$", " ",
    "$P_{\\mathrm{slope}}$",
    "$P_{\\mathrm{region}}$",
    "$P_{\\mathrm{slope:region}}$"
  ),
  align = "llrcrrr"
)
```

## 3.x. Separate-regions models with combinations of variables

```{r fit-all-sep-region-models}
predictor_names <- HDS %>%
  {names(.)[str_which(names(.), "roughness")]} %>%
  paste(collapse = " + ")
models <- list(
  GCFR_HDS_richness = lm(
    formula = glue("HDS_richness      ~ {predictor_names}"),
    data    = GCFR_HDS
  ),
  GCFR_QDS_richness = lm(
    formula = glue("QDS_richness      ~ {predictor_names}"),
    data    = GCFR_QDS
  ),
  GCFR_QDS_turnover = lm(
    formula = glue("add_turnover_prop ~ {predictor_names}"),
    data    = GCFR_HDS
  ),
  SWAFR_HDS_richness = lm(
    formula = glue("HDS_richness      ~ {predictor_names}"),
    data    = SWAFR_HDS
  ),
  SWAFR_QDS_richness = lm(
    formula = glue("QDS_richness      ~ {predictor_names}"),
    data    = SWAFR_QDS
  ),
  SWAFR_QDS_turnover = lm(
    formula = glue("add_turnover_prop ~ {predictor_names}"),
    data    = SWAFR_HDS
  )
)
# Fit all possible model subsets
# (WARNING: this takes a while... Only run if haven't already...)
save_file <- here("draft-02/outputs/fit-all-sep-region-models.RDS")
if (file.exists(save_file)) {
  models <- read_rds(save_file)
} else {
  # (... Or import from disc.)
  models %<>% map(ols_step_all_possible)
  write_rds(models, save_file)
}
```

```{r fit-best-sep-region-models}
best_preds <- map(models, .id = "model",
  ~ .x %>%
    as_tibble() %>%
    mutate(delta_aic = aic - min(aic)) %>%
    arrange(delta_aic) %>%
    dplyr::select(predictors, adjr, delta_aic) %>%
    slice(1) %>%
    pull(predictors) %>%
    str_replace_all(" ", " + ")
)
new_models <- list(
  GCFR_HDS_richness = lm(
    formula = glue("HDS_richness      ~ {best_preds$GCFR_HDS_richness}"),
    data   = GCFR_HDS
  ),
  GCFR_QDS_richness = lm(
    formula = glue("QDS_richness      ~ {best_preds$GCFR_QDS_richness}"),
    data    = GCFR_QDS
  ),
  GCFR_QDS_turnover = lm(
    formula = glue("add_turnover_prop ~ {best_preds$GCFR_QDS_turnover}"),
    data    = GCFR_HDS
  ),
  SWAFR_HDS_richness = lm(
    formula = glue("HDS_richness      ~ {best_preds$SWAFR_HDS_richness}"),
    data    = SWAFR_HDS
  ),
  SWAFR_QDS_richness = lm(
    formula = glue("QDS_richness      ~ {best_preds$SWAFR_QDS_richness}"),
    data    = SWAFR_QDS
  ),
  SWAFR_QDS_turnover = lm(
    formula = glue("add_turnover_prop ~ {best_preds$SWAFR_QDS_turnover}"),
    data    = SWAFR_HDS
  )
)
```

```{r summarise-sep-region-models}
models_summary <- new_models %>%
  map_df(.id = "response", tidy, conf.int = TRUE) %>%
  dplyr::select(-std.error, -statistic) %>%
  filter(term != "(Intercept)") %>%
  mutate(term = str_remove_all(term, "_roughness")) %>%
  separate(response, c("region", "scale", "response")) %>%
  unite(response, scale, response)
models_summary_printable <- models_summary %>%
  dplyr::select(-conf.high, -conf.low) %>%
  mutate(
    response = case_when(
      response == "HDS_richness" ~ "$S_{\\mathrm{HDS}}$",
      response == "QDS_richness" ~ "$S_{\\mathrm{QDS}}$",
      response == "QDS_turnover" ~ "$T_{\\mathrm{QDS}} / S_{\\mathrm{HDS}}$"
    ),
    sig = case_when(
      p.value <= 0.05 ~ "*",
      p.value <= 0.10 ~ ".",
      TRUE            ~ " "
    )
  ) %>%
  mutate_if(is.numeric, ~format(round(.x, digits = 3), nsmall = 3))
```

```{r print-sep-region-models-summary}
knitr::kable(models_summary_printable,
  caption = paste(
    "Results of bi-directional stepwise multiple linear regressions of",
    "three richness and turnover responses in the against additive",
    "combinations of environmental heterogeneity variables. The stepwise",
    "regression procedure started with all variables included.",
    "(See Figure 5 for a graphical representation.)"
  ),
  col.names = c("Region", "Response", "Predictor", "Slope", "$P_{slope}$", " "),
  align = "lllrrc"
)
```

```{r R2-sep-region-models}
models_R2 <- new_models %>% 
  map_df(.id = "response", glance) %>%
  dplyr::select(response, adj.r.squared) %>%
  separate(response, c("region", "scale", "response")) %>%
  unite(response, scale, response)
models_R2_printable <- models_R2 %>%
  mutate(adj.r.squared = adj.r.squared %>%
    round(digits = 3) %>%
    format(nsmall = 3)
  ) %>%
  spread(region, adj.r.squared) %>%
  mutate(response = case_when(
    response == "HDS_richness" ~ "$S_{\\mathrm{HDS}}$",
    response == "QDS_richness" ~ "$S_{\\mathrm{QDS}}$",
    response == "QDS_turnover" ~ "$T_{\\mathrm{QDS}} / S_{\\mathrm{HDS}}$"
  ))
```

```{r print-sep-region-models-R2}
knitr::kable(models_R2_printable,
  caption = "Adjusted $R^2$-values of the models in Table 5.",
  col.names = c(
    "Response",
    "GCFR ${R^2}_{\\mathrm{adj.}}$", "SWAFR ${R^2}_{\\mathrm{adj.}}$"
  ),
  align = "lrr"
)
```

```{r plot-sep-region-models-summary, fig.width=6, fig.height=5, fig.cap="Slopes from Table 5, with error bars denoting 95% confidence intervals about each slope estimate."}
models_summary_for_plot <- models_summary %>% 
  mutate(
    response = case_when(
      response == "HDS_richness" ~ "(a)~~italic(S)[HDS]",
      response == "QDS_richness" ~ "(b)~~italic(S)[QDS]",
      response == "QDS_turnover" ~ "(c)~~italic(T)[QDS]/italic(S)[HDS]"
    ),
    term = term %>%
      str_replace_all("\\.", " ") %>%
      factor(levels = var_names),
    sig = case_when(
      p.value > 0.10 ~ "NS",
      p.value > 0.05 ~ "AS",
      TRUE           ~ " "
    )
  )
ggplot(models_summary_for_plot) +
  aes(term, estimate, fill = region, group = region) +
  geom_hline(yintercept = 0, linetype = "dashed", colour = "grey75") +
  geom_errorbar(
    aes(ymin = conf.low, ymax = conf.high),
    position = position_dodge(width = 0.25),
    width = 0
  ) +
  geom_point(
    shape = 21,
    position = position_dodge(width = 0.25)
  ) +
  geom_text(aes(label = sig), nudge_x = 0.375, size = 3) +
  labs(x = "Predictor", y = "Slope") +
  scale_fill_manual(name = "Region", values = c("black", "white")) +
  facet_wrap(~response, nrow = 3, scales = "free_y", labeller = label_parsed) +
  theme(
    axis.text.x  = element_text(angle = 90, hjust = 1),
    strip.text.x = element_text(angle =  0, hjust = 0)
  )
```

```{plot-sep-region-models-fits, eval=FALSE}
tibble(model = new_models) %>%
  mutate(
    vis = map(model, visreg::visreg, gg = TRUE),
    coefficients = model %>%
      map("coefficients") %>%
      map(names) %>%
      map(~.x[.x != "(Intercept)"])
  ) #%>%
  # FIXME:
  #mutate(gg = map(vis, map, ~qplot(.x$fit))) %>%
  #dplyr::select(-vis) %>%
  #unnest(gg) %>%
  #pull(gg)

plot_partial_fits <- function(m, m_title) {
  coefficient_names <- names(m$coefficients)[
    names(m$coefficients) != "(Intercept)"
  ]
  plots <- map(coefficient_names, ~visreg::visreg(m, .x, gg = TRUE))
  plots[-1] %<>% map(~ .x + theme(axis.title.y = element_blank()))
  plot_grid(plotlist = plots, nrow = 1, labels = m_title)
}
#partial_fits <-
new_models %>%
  imap(~ plot_partial_fits(
    .x,
    paste("(a)", str_extract(.y, "(GCFR|SWAFR)"))
  ))
```

## 3.2. Combined-regions models with individual variables

### 3.2.2. PC1 models

Here, I present my findings with raw R-code, because I don't have the time to format it neatly.

```{r combined-region-PC1-models-1, echo=TRUE}
m1 <- lm(HDS_richness ~ PC1,          HDS)
m2 <- lm(HDS_richness ~ PC1 + region, HDS)
m3 <- lm(HDS_richness ~ PC1 * region, HDS)
my_AIC_table(m1, m2, m3, caption = "Richness (HDS)")
# Therefore, "choose" m1 ("no region" model)
```

```{r combined-region-PC1-models-2, echo=TRUE}
m1 <- lm(QDS_richness ~ PC1,          QDS)
m2 <- lm(QDS_richness ~ PC1 + region, QDS)
m3 <- lm(QDS_richness ~ PC1 * region, QDS)
my_AIC_table(m1, m2, m3, caption = "Richness (QDS)")
# Therefore, "choose" m1 ("no region" model) (?)
```

```{r combined-region-PC1-models-3, echo=TRUE}
m1 <- lm(add_turnover ~ PC1,          HDS)
m2 <- lm(add_turnover ~ PC1 + region, HDS)
m3 <- lm(add_turnover ~ PC1 * region, HDS)
my_AIC_table(m1, m2, m3, caption = "Turnover")
# Therefore, "choose" m1 ("no region" model)
```

```{r combined-region-PC1-models-4, echo=TRUE}
m1 <- lm(add_turnover_prop ~ PC1 ,         HDS)
m2 <- lm(add_turnover_prop ~ PC1 + region, HDS)
m3 <- lm(add_turnover_prop ~ PC1 * region, HDS)
my_AIC_table(m1, m2, m3, caption = "Turnover (proportional)")
# Therefore, "choose" m3 ("int. region" model)
```

```{r plot-combined-region-PC1-models}
S_HDS_plot <- ggplot(HDS, aes(PC1, HDS_richness)) +
  geom_smooth(method = lm, colour = "grey25") +
  geom_point(aes(fill = region), shape = 21, colour = "black") +
  ylab(bquote(italic("S")["HDS"])) +
  scale_fill_manual(name = "Region", values = c("black", "white"))

S_QDS_plot <- ggplot(QDS, aes(PC1, QDS_richness)) +
  geom_smooth(method = lm, colour = "grey25") +
  geom_point(aes(fill = region), shape = 21, colour = "black") +
  ylab(bquote(italic("S")["QDS"])) +
  scale_fill_manual(name = "Region", values = c("black", "white"))

turnover_plot <- ggplot(HDS, aes(PC1, add_turnover)) +
  geom_smooth(method = lm, colour = "grey25") +
  geom_point(aes(fill = region), shape = 21, colour = "black") +
  ylab(bquote(italic("T")["QDS"])) +
  scale_fill_manual(name = "Region", values = c("black", "white"))

turnover_prop_plot <- ggplot(HDS, aes(PC1, add_turnover_prop, group = region)) +
  geom_smooth(method = lm, colour = "grey25") +
  geom_point(aes(fill = region), shape = 21, colour = "black") +
  ylab(bquote(italic("T")["QDS"] / italic("S")["HDS"])) +
  scale_fill_manual(name = "Region", values = c("black", "white"))

my_plots <- list(
  S_HDS_plot + theme(
    axis.title.x = element_blank(),
    axis.text.x  = element_blank(),
    axis.ticks.x = element_blank()
  ),
  #S_QDS_plot,     # needed?
  #turnover_plot,  # needed?
  turnover_prop_plot
)
my_legend <- get_legend(my_plots[[1]])
my_plots %<>% map(~ .x + theme(
  legend.position = "none",
  axis.text.y     = element_text(angle = 90)
))

plot_grid(
  plot_grid(
    plotlist = my_plots[1:2],
    nrow = 2,
    rel_heights = c(0.9, 1),
    labels = glue("({letters[1:2]})")
  ),
  my_legend,
  nrow = 1,
  rel_widths = c(2, 1)
)
```

## 3.3. Combined-regions models with combinations of variables

```{r, eval=FALSE}
m_all <- lm(
  HDS_richness ~
    Elevation_mean_value + Elevation_roughness +
    MAP_mean_value       + MAP_roughness +
    NDVI_mean_value      + NDVI_roughness +
    PDQ_mean_value       + PDQ_roughness +
    pH_mean_value        + pH_roughness +
    Soil.C_mean_value    + Soil.C_roughness +
    Surface.T_mean_value + Surface.T_roughness,
  HDS
)
summary(m_all)
m_all_step <- ols_step_all_possible(m_all)
summary(m_all_step)

m_all_int <- lm(
  HDS_richness ~
    Elevation_mean_value          + Elevation_roughness +
    MAP_mean_value                + MAP_roughness +
    NDVI_mean_value               + NDVI_roughness +
    PDQ_mean_value                + PDQ_roughness +
    pH_mean_value                 + pH_roughness +
    Soil.C_mean_value             + Soil.C_roughness +
    Surface.T_mean_value          + Surface.T_roughness +
    Elevation_mean_value * region + Elevation_roughness * region +
    MAP_mean_value       * region + MAP_roughness       * region +
    NDVI_mean_value      * region + NDVI_roughness      * region +
    PDQ_mean_value       * region + PDQ_roughness       * region +
    pH_mean_value        * region + pH_roughness        * region +
    Soil.C_mean_value    * region + Soil.C_roughness    * region +
    Surface.T_mean_value * region + Surface.T_roughness * region,
  HDS
)
m_all_int2 <- lm(
  QDS_richness ~
    Elevation_mean_value          + Elevation_roughness +
    MAP_mean_value                + MAP_roughness +
    NDVI_mean_value               + NDVI_roughness +
    PDQ_mean_value                + PDQ_roughness +
    pH_mean_value                 + pH_roughness +
    Soil.C_mean_value             + Soil.C_roughness +
    Surface.T_mean_value          + Surface.T_roughness +
    Elevation_mean_value * region + Elevation_roughness * region +
    MAP_mean_value       * region + MAP_roughness       * region +
    NDVI_mean_value      * region + NDVI_roughness      * region +
    PDQ_mean_value       * region + PDQ_roughness       * region +
    pH_mean_value        * region + pH_roughness        * region +
    Soil.C_mean_value    * region + Soil.C_roughness    * region +
    Surface.T_mean_value * region + Surface.T_roughness * region,
  QDS
)
summary(m_all_int)
summary(m_all_int2)
m_all_int_step <- step(m_all_int)
m_all_int_step2 <- step(m_all_int2)
summary(m_all_int_step)
summary(m_all_int_step2)
non_sigs <- m_all_int_step %>%
  tidy() %>%
  filter(p.value > 0.05, term != "(Intercept)") %>%
  pull(term) %>%
  paste(collapse = " - ") %>%
  {paste("-", .)}

m_all_int_step_manual <- update(
  m_all_int_step,
  as.formula(paste("~ .", non_sigs))
)
summary(m_all_int_step_manual)
non_sigs <- m_all_int_step_manual %>%
  tidy() %>%
  filter(p.value > 0.05, term != "(Intercept)") %>%
  pull(term) %>%
  paste(collapse = " - ") %>%
  {paste("-", .)}
m_all_int_step_manual2 <- update(
  m_all_int_step_manual,
  as.formula(paste("~ .", non_sigs))
)
summary(m_all_int_step_manual2)

AIC(m_all, m_all_step, m_all_int, m_all_int_step)

foo <- tibble(
  fit    = m_all_int_step$fitted.values,
  obs    = HDS$HDS_richness,
  region = HDS$region
)
ggplot(foo, aes(obs, fit)) +
  geom_smooth(method = lm, colour = "black") +
  geom_point(aes(colour = region))
#plot(m_all_int_step)

foo2 <- tibble(
  fit    = m_all_int_step2$fitted.values,
  obs    = QDS$QDS_richness,
  region = QDS$region
)
ggplot(foo2, aes(obs, fit)) +
  geom_smooth(method = lm, colour = "black") +
  geom_point(aes(colour = region), alpha = 0.25)
#plot(m_all_int_step2)

# (*) Plots --------------------------------------------------------------------

ggplot(HDS, aes(PC1, HDS_richness)) +
  geom_point(aes(colour = region)) +
  geom_smooth(method = lm, colour = "black")
ggplot(QDS, aes(PC1, QDS_richness)) +
  geom_point(aes(colour = region)) +
  geom_smooth(method = lm, colour = "black")
m <- lm(HDS_richness ~ PC1, HDS)
#plot(m)
ggplot(HDS, aes(Elevation_mean_value, HDS_richness)) +
  geom_point(aes(colour = region)) +
  geom_smooth(method = lm, colour = "black")
ggplot(HDS, aes(Elevation_roughness, HDS_richness)) +
  geom_point(aes(colour = region)) +
  geom_smooth(method = lm, colour = "black")

ggplot(HDS, aes(PC1, Elevation_roughness, colour = region)) +
  geom_point()
ggplot(HDS, aes(PC2, Elevation_roughness, colour = region)) +
  geom_point()

ggplot(QDS, aes(lon, lat, colour = PC1)) +
  geom_point(size = 3) +
  facet_grid(~region, scales = "free_x") +
  scale_colour_viridis_c()

ggplot(HDS, aes(lon, lat, colour = PC1)) +
  geom_point(size = 3) +
  facet_wrap(~region, scales = "free") +
  scale_colour_viridis_c()
ggplot(HDS, aes(lon, lat, colour = PC2)) +
  geom_point(size = 3) +
  facet_wrap(~region, scales = "free")

# (...) PCA biplots again ------------------------------------------------------

HDS_PCA      <- read_rds(here("outputs/QDS_roughness_cells_PCA.RDS"))
HDS_PCA_data <- read_csv(here("outputs/QDS_roughness_cells_prepped.csv"))
QDS_PCA      <- read_rds(here("outputs/EDS_roughness_cells_PCA.RDS"))
QDS_PCA_data <- read_csv(here("outputs/EDS_roughness_cells_prepped.csv"))

# Log to match PCA
HDS_PCA_data[, -c(1, 2)] %<>% log()
QDS_PCA_data[, -c(1, 2)] %<>% log()

autoplot(HDS_PCA,
  data            = HDS_PCA_data,
  colour          = "region",
  loadings        = TRUE,
  loadings.colour = "blue",
  loadings.label  = TRUE
)
autoplot(QDS_PCA,
  data            = QDS_PCA_data,
  colour          = "region",
  loadings        = TRUE,
  loadings.colour = "blue",
  loadings.label  = TRUE
)

HDS %>%
  filter(n_QDS == 4) %>%
  dplyr::select(region, PC1, PC2) %>%
  group_by(region) %>%
  summarise_all(.funs = list(mean = mean, sd = sd)) %>%
  mutate(
    PC1_upp = PC1_mean + PC1_sd,
    PC1_low = PC1_mean - PC1_sd,
    PC2_upp = PC2_mean + PC2_sd,
    PC2_low = PC2_mean - PC2_sd
  ) %>%
  ggplot(aes(PC1_mean, PC2_mean, colour = region)) +
    geom_hline(yintercept = 0, lty = "dashed", colour = "grey25") +
    geom_vline(xintercept = 0, lty = "dashed", colour = "grey25") +
    geom_point() +
    geom_errorbar( aes(ymin = PC2_low, ymax = PC2_upp), width  = 0) +
    geom_errorbarh(aes(xmin = PC1_low, xmax = PC1_upp), height = 0) +
    geom_point(
      data    = filter(HDS, n_QDS == 4),
      mapping = aes(PC1, PC2, colour = region),
      alpha   = 0.5
    ) +
    theme_minimal()

QDS %>%
  filter(n_EDS == 4) %>%
  dplyr::select(region, PC1, PC2) %>%
  group_by(region) %>%
  summarise_all(.funs = list(mean = mean, sd = sd)) %>%
  mutate(
    PC1_upp = PC1_mean + PC1_sd,
    PC1_low = PC1_mean - PC1_sd,
    PC2_upp = PC2_mean + PC2_sd,
    PC2_low = PC2_mean - PC2_sd
  ) %>%
  ggplot(aes(PC1_mean, PC2_mean, colour = region)) +
    geom_hline(yintercept = 0, lty = "dashed", colour = "grey25") +
    geom_vline(xintercept = 0, lty = "dashed", colour = "grey25") +
    geom_point() +
    geom_errorbar( aes(ymin = PC2_low, ymax = PC2_upp), width  = 0) +
    geom_errorbarh(aes(xmin = PC1_low, xmax = PC1_upp), height = 0) +
    geom_point(
      data    = filter(QDS, n_EDS == 4),
      mapping = aes(PC1, PC2, colour = region),
      alpha   = 0.25
    ) +
    theme_minimal()

ggplot(HDS, aes(PC1, PC2, colour = PC2 > 0)) +
  geom_point()

HDS %>%
  split(.$region) %>%
  map(~.x %$% table(PC2 > 0, PC1 > 0))

my_PCA_plot <- function(data) {
  get_lim <- function(x) {
    lim <- ceiling(max(x))
    c(-lim, lim)
  }
  plot_xlim <- get_lim(data$PC1)
  plot_ylim <- get_lim(data$PC2)
  no_legend_no_grid <- theme(
    legend.position  = "none",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
  white_rect <- grid::grid.rect(gp = grid::gpar(col = "white"))

  PC1_histograms <- ggplot(data, aes(PC1, fill = region)) +
    geom_histogram(bins = 20, position = "dodge") +
    xlim(plot_xlim) +
    theme_minimal() +
    theme(
      axis.title.x       = element_blank(),
      axis.text.x        = element_blank(),
      axis.text.y        = element_text(angle = 90),
      axis.line.x.bottom = element_blank(),
      axis.line.x.top    = element_blank(),
      axis.line.y.right  = element_blank()
    ) +
    no_legend_no_grid
  PC2_histograms <- ggplot(data, aes(PC2, fill = region)) +
    geom_histogram(bins = 20, position = "dodge") +
    xlim(plot_ylim) +
    coord_flip() +
    theme_minimal() +
    theme(
      axis.title.y       = element_blank(),
      axis.text.y        = element_blank(),
      axis.line.y.right  = element_blank(),
      axis.line.y.left   = element_blank(),
      axis.line.x.top    = element_blank()
    ) +
    no_legend_no_grid

  PCA_biplot <- ggplot(data, aes(PC1, PC2, colour = region)) +
    geom_hline(yintercept = 0, lty = "dashed", colour = "grey25") +
    geom_vline(xintercept = 0, lty = "dashed", colour = "grey25") +
    geom_point() +
    lims(x = plot_xlim, y = plot_ylim) +
    theme_bw() +
    theme(axis.text.y = element_text(angle = 90)) +
    no_legend_no_grid

  cowplot::plot_grid(
    PC1_histograms, white_rect,
    PCA_biplot,     PC2_histograms,
    ncol = 2,
    rel_widths = c(4, 1), rel_heights = c(1, 4)
  )
}
foo <- my_PCA_plot(HDS)
foo
PC1_histograms <- ggplot(QDS, aes(PC1, fill = region)) +
  xlim(-5, 5) +
  geom_histogram(bins = 20, position = "dodge") +
  theme_minimal() +
  theme(legend.position = "none", axis.title.x = element_blank(),
                                  axis.text.x = element_blank(),
                                  axis.text.y = element_text(angle = 90),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
PC2_histograms <- ggplot(QDS, aes(PC2, fill = region)) +
  xlim(-5, 5) +
  geom_histogram(bins = 20, position = "dodge") +
  coord_flip() +
  theme_minimal() +
  theme(legend.position = "none", axis.title.y = element_blank(),
                                  axis.text.y = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
PC_biplot <- ggplot(QDS, aes(PC1, PC2, colour = region)) +
  lims(x = c(-5, 5), y = c(-5, 5)) +
  geom_hline(yintercept = 0, lty = "dashed", colour = "grey25") +
  geom_vline(xintercept = 0, lty = "dashed", colour = "grey25") +
  geom_point() +
  theme_bw() +
  theme(legend.position = "none", axis.text.y = element_text(angle = 90),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

white_rect <- grid::grid.rect(gp = grid::gpar(col = "white"))
cowplot::plot_grid(
  PC1_histograms, white_rect,
  PC_biplot,      PC2_histograms,
  ncol = 2,
  rel_widths = c(4, 1), rel_heights = c(1, 4)
)

PC1_histograms <- ggplot(HDS, aes(PC1, fill = region)) +
  #xlim(-5, 5) +
  geom_histogram(bins = 20, position = "dodge") +
  theme_minimal() +
  theme(legend.position = "none", axis.title.x = element_blank(),
                                  axis.text.x = element_blank(),
                                  axis.title.y = element_blank(),
                                  axis.text.y = element_blank(),
                                  #axis.text.y = element_text(angle = 90),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
PC2_histograms <- ggplot(HDS, aes(PC2, fill = region)) +
  #xlim(-5, 5) +
  geom_histogram(bins = 20, position = "dodge") +
  coord_flip() +
  theme_minimal() +
  theme(legend.position = "none", axis.title.y = element_blank(),
                                  axis.text.y = element_blank(),
                                  axis.title.x = element_blank(),
                                  axis.text.x = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
PC_biplot <- ggplot(HDS, aes(PC1, PC2, colour = region)) +
  #lims(x = c(-5, 5), y = c(-5, 5)) +
  geom_hline(yintercept = 0, lty = "dashed", colour = "grey25") +
  geom_vline(xintercept = 0, lty = "dashed", colour = "grey25") +
  geom_point() +
  theme_bw() +
  theme(legend.position = "none", axis.text.y = element_text(angle = 90),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

white_rect <- grid::grid.rect(gp = grid::gpar(col = "white"))
cowplot::plot_grid(
  PC1_histograms, white_rect,
  PC_biplot,      PC2_histograms,
  ncol = 2,
  rel_widths = c(4, 1), rel_heights = c(1, 4)
)

all_PCA_data <- rbind(
  cbind(scale = "HDS", HDS_PCA_data[, -2]),
  cbind(scale = "QDS", QDS_PCA_data[, -2])
)

foo <- prcomp(all_PCA_data[, -c(1, 2)], scale. = TRUE)
if (all(foo$rotation[, 1] <= 0)) {
  foo$rotation[, 1] %<>% multiply_by(-1)
  foo$x[, 1]        %<>% multiply_by(-1)
}
autoplot(foo, data = unite(all_PCA_data, region_scale, region, scale), colour = "region_scale", alpha = 0.25)
```
