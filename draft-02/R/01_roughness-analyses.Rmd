# 1. Environmental heterogeneity & scale

Is the GCFR more heterogeneous environmentally than the SWAFR, and does the scale of that heterogeneity differ to that of the SWAFR?

In order to determine which region is more environmentally heterogeneous, and what scales heterogeneity is most pronounced, we calculated a measure of environmental heterogeneity at various spatial scales (namely: the base data resolution (0.05ยบ x 0.05ยบ), eighth- (EDS), quarter- (QDS), half- (HDS) and three-quarter-degree-squares (3QDS)).

Environmental "roughness" in both regions was calculated, in moving 3 x 3 cell windows, as the average absolute difference between cells and their (usually) 8 neighbours. Alternatively, for a focal cell $x^*$, the roughness is based on $x_1, x_2, \dots, x_i, \dots, x_8$ neighbour cells as:

$$
  Roughness(x^*) =
    f \left( \begin{matrix}
      x_1 & x_2 & x_3 \\
      x_4 & x^* & x_5 \\
      x_6 & x_7 & x_8
    \end{matrix} \right) =
    \frac{1}{8} \sum_i |x^* - x_i|
$$

In R, this is implemented this as follows:

```{r print-roughness-body, echo=TRUE, eval=FALSE}
roughness <- function(x) {
  raster::focal(x, matrix(1, nrow = 3, ncol = 3), function(x) {
    focal_cell <- x[5]
    focal_exists <- (!is.na(focal_cell)) & (!is.nan(focal_cell))
    if (focal_exists) {
      neighbour_exists <- (!is.na(x)) & (!is.nan(x)) & (x != focal_cell)
      neighbour_cells <- x[neighbour_exists]
      return(mean(abs(focal_cell - neighbour_cells)))
    } else {
      return(NA)
    }
  })
}
```

Following this, the various forms environmental heterogeneity were ordinated using principal component analysis (PCA), to summarise a major axis of heterogeneity in each region (Figure 1). Portions of the data matrices for each scale for these PCAs are shown in Table 1.

Both the actual environmental heterogeneity values and the principal component of heterogeneity were then compared between the GCFR and SWAFR using common language effect sizes ($CLES$). The $CLES$ of GCFR vs SWAFR heterogeneity values was regressed against the spatial scale at which it was calculated using simple linear regression (Figure 2, Table 2).

We can see that PDQ, NDVI, pH and, arguably, elevation are all consistently more heterogeneous in the GCFR than in the SWAFR, regardless of spatial scale (Figure 2). The GCFR is more heterogeneous at finer scales in terms of MAP, surface temperature, CEC and soil carbon (Figure 2). Notably, the GCFR is more pronouncedly heterogeneous at broad scales in terms of clay (Figure 2). In general (i.e. regarding PC1; Figure 2), the GCFR is more environmentally heterogeneous than the SWAFR, and particularly so at fine spatial scales.

```{r import-roughness-matrices, include=FALSE}
output_path      <- here("draft-02/outputs/roughness")
resolutions      <- c("base", "EDS", "QDS", "HDS", "3QDS")
matrix_filenames <- glue("{output_path}/{resolutions}_roughness_matrix.csv")

roughness_matrices <- map(matrix_filenames, read_csv)
names(roughness_matrices) <- resolutions
```

```{r print-roughness-matrix-example}
roughness_matrices %$%
  base %>%
  mutate_if(is.numeric, log1p) %>%
  mutate_if(is.numeric, round, digits = 2) %>%
  {rbind(.[1:3, ], rep("...", 11), tail(.)[1:3, ])} %>%
  knitr::kable(caption = paste(
    "Portions of the data matrices used in the PCA for this",
    "section of the analysis, where roughness values were",
    "$log(x + 1)$-transformed to ensure normality."
  ))
```

```{r PCA-analysis, include=FALSE}
roughness_PCAs <- map(roughness_matrices,
  ~ .x[, -1] %>%
    log1p() %>%
    prcomp(scale. = TRUE)
)

# Force PC1 scores to be positive if all vars rotations are negative
roughness_PCAs %<>% map(function(PCA) {
  if (all(PCA$rotation[, 1] <= 0)) {
    PCA$rotation[, 1] %<>% multiply_by(-1)
    PCA$x[, 1]        %<>% multiply_by(-1)
  }
  PCA
})

# Store PC1 & 2 in matrices for later
roughness_matrices <- map2(roughness_PCAs, roughness_matrices,
  function(PCA, layer) {
    layer$PC1 <- PCA$x[, 1]
    layer$PC2 <- PCA$x[, 2]
    layer
  }
)
```

```{r plot-PCA, fig.height=8, fig.cap="Scatter plots of the first and second principal components (PC1, PC2) of environmental heterogeneity following principal components analyses (PCAs) of the various forms of environmental heterogeneity, repeated at the five spatial scales. The proportion of variation accounted for by each axis is denoted in parentheses. Arrows (labelled) denote the rotational loading of a given form of environmental heterogeneity. Note, the signs of loadings on PC1 have been forced to be positive, while the signs of loadings on PC2 are arbitrary."}
roughness_PCA_plots <- map2(roughness_PCAs, roughness_matrices,
  ~ autoplot(.x,
      data = .y, colour = "region", alpha = 0.25,
      loadings = TRUE, loadings.colour = "black",
      loadings.label = TRUE, loadings.label.colour = "black",
      loadings.label.hjust = -0.25
    ) +
    geom_hline(yintercept = 0, lty = "dashed", alpha = 0.5) +
    geom_vline(xintercept = 0, lty = "dashed", alpha = 0.5)
)
# Get legend to use as panel
my_legend <- get_legend(roughness_PCA_plots[[1]])
# Remove legends from PCA plots themselves
roughness_PCA_plots %<>% map(~.x + theme(legend.position = "none"))
# Store panels in list
roughness_PCA_plots <- c(roughness_PCA_plots, my_legend = list(my_legend))
# Plot panels
plot_grid(
  plotlist = roughness_PCA_plots,
  labels   = c("0.05ยบ", "EDS", "QDS", "HDS", "3QDS", ""),
  nrow     = 3
)
```

```{r map-PCA}
# TODO: Plot maps of exemplary roughness variables and PC1
```

```{r CLES-analysis, include=FALSE}
GCFR_roughness_data <- roughness_matrices %>%
  map(filter, region == "GCFR") %>%
  map(dplyr::select, -region, -PC2)
SWAFR_roughness_data <- roughness_matrices %>%
  map(filter, region == "SWAFR") %>%
  map(dplyr::select, -region, -PC2)

# (WARNING: this takes a while... Only run if haven't already...)
if (!file.exists(glue("{output_path}/CLES_results.csv"))) {
  set.seed(1234)
  CLES_results <- map2_df(GCFR_roughness_data, SWAFR_roughness_data,
    .id = "resolution",  # for every spatial resolution,
    ~ map2_df(.x, .y,
      .id = "variable",  # for every variable in each region,
      ~tibble(CLES_value = CLES(.y, .x))
    )
  )
  # Save results to disc
  write_csv(
    CLES_results,
    glue("{output_path}/CLES_results.csv")
  )
} else {  # (... Or import from disc.)
  CLES_results <- read_csv(glue("{output_path}/CLES_results.csv"))
}

# Tidy
CLES_results %<>%
  filter(variable != "region", variable != "PC2") %>%
  mutate(resolution = case_when(
    resolution == "base" ~ 0.05,
    resolution == "EDS"  ~ 0.125,
    resolution == "QDS"  ~ 0.25,
    resolution == "HDS"  ~ 0.50,
    resolution == "3QDS" ~ 0.75
  )) %>%
  mutate(variable = factor(variable, levels = c(
    "Elevation",
    "MAP", "PDQ", "Surface.T",
    "NDVI",
    "CEC", "Clay", "Soil.C", "pH",
    "PC1"
  )))
```

```{r model-CLES}
# Fit linear models of CLES ~ spatial scale for each variable
CLES_models <- CLES_results %>%
  split(.$variable) %>%
  map(~lm(CLES_value ~ resolution, .x))
# Summarise those models
CLES_model_summaries <- CLES_models %>%
  map_df(.id = "variable", tidy) %>%
  filter(term != "(Intercept)") %>% 
  mutate(sig = case_when(
    p.value <= 0.05 ~ "*",
    p.value <= 0.10 ~ ".",
    TRUE            ~ " "
  )) %>%
  mutate(variable = factor(variable, levels = var_names %>%
    str_replace_all(" ", ".") %>%
    c("PC1")
  )) %>%
  mutate_if(is.numeric, round, digits = 3) %>%
  dplyr::select(variable, estimate, p.value, sig)
# Print table
knitr::kable(CLES_model_summaries,
  caption = paste(
    "Slopes and associated $P$-values from simple linear regressions",
    "of $CLES$ against scale for each form of environmental roughness",
    "(Figure 2)."
  ),
  col.names = c("Variable", "Slope", "$P$", " "),
  align = "lrrc"
)
```

```{r test-CLES-against-zero, include=FALSE}
# Also show how I tested for CLES different to zero
CLES_results %>%
  split(.$variable) %>%
  map(pull, CLES_value) %>%
  map(t.test) %>%
  map_df(.id = "variable", tidy) %>%
  dplyr::select(variable, p.value) %>%
  mutate(sig = p.value < 0.001)
```

```{r plot-CLES-fits, fig.cap="Simple linear regressions of the common language effect size ($CLES$) of various forms of environmental heterogeneity (a--i), and the first principal component of heterogeneity (j; see Figure 1), where the $CLES$ is treated as the effect of GCFR relative to SWAFR values. Only significant or marginally significant fits are plotted (Table 2). Grey bands denote 95% confidence intervals about the fitted lines. Across spatial scales, all $CLES$ values differed significantly from zero following two-sided $t$-tests ($P < 0.001$)."}
# Neaten variable labels to include panel letters
CLES_results %<>%
  mutate(
    variable = variable %>%
      as.character() %>%
      str_replace_all("\\.", " "),
    letters = rep(letters[1:10], 5),
    label = glue("({letters}) {variable}")
  )
  
# Create empty panels
empty_plots <- ggplot(CLES_results, aes(resolution, CLES_value)) +
  geom_hline(yintercept = 0.5, lty = "dashed") +
  facet_wrap(~label, nrow = 2) +
  scale_x_continuous(
    name   = "Scale",
    breaks = c(0.05,   0.125, 0.25,  0.50,  0.75),
    labels = c("0.05ยบ", "EDS", "QDS", "HDS", "3QDS")
  ) +
  scale_y_continuous(
    name   = "CLES\n(GCFR > SWAFR)",
    breaks = c(0.50, 0.75, 1.00)      
  ) +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 90)
  )
# Create dataset without data for NS regressions (above),
# so that geom_smooth() can't plot for those variables
CLES_results_sans_NS <- mutate(CLES_results,
  CLES_value = ifelse(variable %in% c("NDVI", "PDQ", "pH"),
    NA,
    CLES_value
  )
)
# Add fits to empty plots
CLES_plots <- empty_plots +
  geom_smooth(
    data    = CLES_results_sans_NS,
    mapping = aes(group = label),
    method  = lm,
    colour  = "grey25"
  ) +
  # Plot full dataset on top of fits for clarity
  geom_point(data = CLES_results)

CLES_plots
```
