## 3.1. Separate environmental variable models

Tables 5--7 present the results of simple linear regressions of each form of environmental heterogeneity separately as predictors of each of the three response variables ($S_{\mathrm{HDS}}$, $S_{\mathrm{QDS}}$ and $T_{\mathrm{QDS}} / S_{\mathrm{HDS}}$ respectively). In each table, the "best" model (sensu $AIC$) was select as the simplest model with $\Delta AIC < 2$---i.e. a more complex model was only justified when it had the lowest $AIC$-score by more than 2 $AIC$-units.

For $S_{\mathrm{HDS}}$ (Table 4), there is evidence for a great difference in the slopes of the GCFR and SWAFR's relationships with heterogeneity in MAP. Heterogneity in NDVI and clay only present evidence for the same slope in each region, but differing intercepts. Heterogeneity in CEC and pH have non-significant slopes and signficiant region-effects---suggesting that these variables values' have weak relationships with $S_{\mathrm{HDS}}$, and that the region-effect explains more of the variance. Other variables (heterogeneity in elevation, PDQ, surface T and soil C) only present evidence for a continuous effect of that heterogeneity, explaining the difference in the regions' $S_{\mathrm{HDS}}$ in terms of the roughness values themselves, without the need to invoke a region term. Think of it this way:

- If there is no need for any information concerning the region a cell belongs to, then the environmental roughness "rule" is followed well across the two regions in a similar way.
- If the region-effect is significant, but not the roughness effect, then that roughness axis isn't doing a very good job of explaining anything, and must defer to the region-effect.
- When both the region- and roughness-effect are significant, this represents a softer version of the above, where the roughness axis can explain some variance, but not all.
- When there is a significant interaction between region and roughness, then each region is playing a whole new game with that axes in terms of how richness is being driven.

<!--
At the QDS-scale, concerning $S_{\mathrm{QDS}}$ (Table 6), it is noteworthy that all axes best-supported to have an additive region term only also had non-significant roughness-effects [expand?].
-->

In Tables 4 and 5, I also regressed against PC1. Like heterogeneity in elevation and surface T, PC1 was the only explanatory variable "needed" in regressions for $S_{\mathrm{HDS}}$ (also see Figure 4) and $S_{\mathrm{QDS}}$. Figure 4 shows quite nicely how, in general, the GCFR and SWAFR are following the same "rule" (species richness increases with increasing environmental heterogeneity (PC1)) but occupy different areas along that relationship (the GCFR being more rich and more rough than the SWAFR).

It is worth noting that PC1 is representatve of (ca. 45% of) the multivariate trends of species richness and turnover versus environmental heterogeneity. Some of the individual roughness variables show similar trends, some not, and to varying extents [expand].

```{r helper-functions}
fit_combined_region_models <- function(response) {
  stopifnot(exprs = {
    response %in% c("HDS_richness", "QDS_richness", "add_turnover_prop")
    # Datasets must be loaded before running this function
    exists("HDS")
    exists("QDS")
  })
  
  dataset <- if (response == "QDS_richness") QDS else HDS
  
  # Select roughness & PC1 predictor names
  predictor_names <- names(dataset)[
    str_which(names(dataset), "(roughness|PC1)")
  ]
  
  # Fit no-region, additive & interaction models & summarise w/ broom::
  models_no_region <- predictor_names %>%
    map(~lm(glue("{response} ~ {.x}"), dataset)) %>%
    set_names(predictor_names) %>%
    {tibble(predictor = names(.), model = .)} %>%
    mutate(
      slope         = map_dbl(model, ~tidy(.x)$estimate[2]),
      slope_p_value = map_dbl(model, ~tidy(.x)$p.value[ 2]),
      r_squared     = map_dbl(model, ~glance(.x)$r.squared),
      slope_sig     = ifelse(slope_p_value <= 0.05, "*", "")
    )
  models_add_region <- predictor_names %>%
    map(~lm(glue("{response} ~ {.x} + region"), dataset)) %>%
    set_names(predictor_names) %>%
    {tibble(predictor = names(.), model = .)} %>%
    mutate(
      slope          = map_dbl(model, ~tidy(.x)$estimate[2]),
      slope_p_value  = map_dbl(model, ~tidy(.x)$p.value[ 2]),
      region_coeff   = map_dbl(model, ~tidy(.x)$estimate[3]),
      region_p_value = map_dbl(model, ~tidy(.x)$p.value[ 3]),
      r_squared      = map_dbl(model, ~glance(.x)$r.squared),
      slope_sig      = ifelse(slope_p_value  <= 0.05, "*", ""),
      region_sig     = ifelse(region_p_value <= 0.05, "*", "")
    )
  models_int_region <- predictor_names %>%
    map(~lm(glue("{response} ~ {.x} * region"), dataset)) %>%
    set_names(predictor_names) %>%
    {tibble(predictor = names(.), model = .)} %>%
    mutate(
      slope          = map_dbl(model, ~tidy(.x)$estimate[2]),
      slope_p_value  = map_dbl(model, ~tidy(.x)$p.value[ 2]),
      region_coeff   = map_dbl(model, ~tidy(.x)$estimate[3]),
      region_p_value = map_dbl(model, ~tidy(.x)$p.value[ 3]),
      int_coeff      = map_dbl(model, ~tidy(.x)$estimate[4]),
      int_p_value    = map_dbl(model, ~tidy(.x)$p.value[ 4]),
      r_squared      = map_dbl(model, ~glance(.x)$r.squared),
      slope_sig      = ifelse(slope_p_value  <= 0.05, "*", ""),
      region_sig     = ifelse(region_p_value <= 0.05, "*", ""),
      int_sig        = ifelse(int_p_value    <= 0.05, "*", "")
    )
  
  # Neaten up & return
  models_no_region[c(
    "region_coeff", "region_p_value", "region_sig",
    "int_coeff",    "int_p_value",    "int_sig"
  )] <- NA
  models_add_region[c(
    "int_coeff",    "int_p_value",    "int_sig"
  )] <- NA
  models <- as_tibble(rbind(
    cbind(region_term = "none", models_no_region),
    cbind(region_term = "add",  models_add_region),
    cbind(region_term = "int",  models_int_region)
  ))
  models$response <- response
  models
}

check_region_effects_all_same <- function(models) {
  check <- models %>%
    mutate(region_term_name = model %>%
      map(~tidy(.x)$term) %>%
      map_chr(paste, collapse = ", ")
    ) %>%
    pull(region_term_name) %>%
    str_detect("GCFR") %>%
    any()
  if (check) print("Uh-oh! Some region-terms are for GCFR")
}

#compare_combined_region_models2 <- function(models, response = NULL) {
#  if (is.null(response)) {
#    response <- unique(models$response)
#  }
#  
#  # Get AICs etc.
#  models_summary <- models %>%
#    group_by(predictor) %>%
#    mutate(aic = map_dbl(model, AIC)) %>%
#    mutate(
#      model_rank = as.numeric(region_term),
#      delta_aic  = aic - min(aic),
#      # Choose the "best" ^ "simplest" model
#      best_model = (model_rank == min(model_rank[delta_aic < 2]))
#    ) %>%
#    ungroup()
#  
#  models_summary_printable <- models_summary %>%
#    filter(best_model) %>%
#    mutate(
#      model_type = case_when(
#        region_term == "none"                        ~ "Main effect",
#        region_term == "add" & slope_p_value <  0.05 ~ "Main effect + region",
#        region_term == "add" & slope_p_value >= 0.05 ~ "Region only",
#        region_term == "int"                         ~ "Region interaction"
#      ),
#      slope_sign  = ifelse(slope        > 0, "+", "-"),
#      region_sign = ifelse(region_coeff > 0, "+", "-"),
#      int_sign    = ifelse(int_coeff    > 0, "+", "-")
#    ) %>%
#    mutate_at(c("slope_p_value", "region_p_value", "int_p_value"),
#      ~ case_when(
#        .x < 0.001 ~ "***",
#        .x < 0.010 ~ "**",
#        .x < 0.050 ~ "*",
#        .x < 0.100 ~ ".",
#        TRUE       ~ " "
#      )
#    ) %>%
#    dplyr::select(
#      model_type,  predictor,
#      slope_sign,  slope_p_value,
#      region_sign, region_p_value,
#      int_sign,    int_p_value
#    ) %>%
#    arrange(model_type)
#  
#  # Remove variable names after first mention in table
#  models_summary_printable$model_type %<>% as.character()
#  for (pred in unique(models_summary_printable$model_type)) {
#    to_remove <- which(models_summary_printable$model_type == pred)[-1]
#    models_summary_printable$model_type[to_remove] <- " "
#  }
#  
#  models_summary_printable
#}
#  
#  # Make pretty
#  models_summary_printable <- models_summary %>%
#    mutate(
#      predictor = predictor %>%
#        str_remove("_roughness") %>%
#        str_replace_all("\\.", " ") %>%
#        factor(levels = c(var_names, "PC1")),
#      region_term = case_when(
#        region_term == "none" ~ "None",
#        region_term == "add"  ~ "Additive",
#        region_term == "int"  ~ "Interaction",
#      ),
#      best_model = ifelse(best_model, "*", " ")
#    ) %>%
#    arrange(predictor) %>%
#    mutate_at(c("slope_p_value", "region_p_value", "int_p_value"),
#      ~ case_when(
#        .x < 0.001 ~ "***",
#        .x < 0.010 ~ "**",
#        .x < 0.050 ~ "*",
#        .x < 0.100 ~ ".",
#        TRUE       ~ " "
#      )
#    ) %>%
#    mutate_if(is.numeric, ~ case_when(
#      is.na(.x) ~ " ",
#      TRUE      ~ format(round(.x, digits = 2), nsmall = 2)
#    )) %>%
#    mutate_if(is.character, ~ ifelse(is.na(.x), " ", .x)) %>%
#    dplyr::select(
#      predictor, region_term, delta_aic, best_model,
#      slope,        slope_p_value,
#      region_coeff, region_p_value,
#      int_coeff,    int_p_value
#    )
#
#  # Remove variable names after first mention in table
#  models_summary_printable$predictor %<>% as.character()
#  for (pred in unique(models_summary_printable$predictor)) {
#    to_remove <- which(models_summary_printable$predictor == pred)[-1]
#    models_summary_printable$predictor[to_remove] <- " "
#  }
#  
#  # Print summary table
#  response <- case_when(
#    response == "HDS_richness"      ~ "$S_{\\mathrm{HDS}}$",
#    response == "QDS_richness"      ~ "$S_{\\mathrm{QDS}}$",
#    response == "add_turnover_prop" ~ "$T_{\\mathrm{QDS}} / S_{\\mathrm{HDS}}$"
#  )
#  knitr::kable(models_summary_printable,
#    caption = glue(
#      "Results of separate simple linear regressions of {response} \\
#      against environmental heterogeneity variables. Asterisks beside each \\
#      $\\Delta AIC$ denote the simples model with $\\Delta AIC < 2$. \\
#      Asterisks beside regression coefficients denote $P$-values < 0.05, \\
#      while periods (\".\") denote $P$-values > 0.05 but < 0.10."
#    ),
#    col.names = c(
#      "Heterogeneity predictor", "Region-term",
#      "$\\Delta AIC$", " ",
#      "Slope",         " ",
#      "SWAFR effect", " ",
#      "Slope:SWAFR",  " "
#    ),
#    align = "llrlrlrlrl"
#  )
#}
compare_combined_region_models <- function(models, response = NULL) {
  if (is.null(response)) {
    response <- unique(models$response)
  }
  
  # Get AICs etc.
  models_summary <- models %>%
    group_by(predictor) %>%
    mutate(aic = map_dbl(model, AIC)) %>%
    mutate(
      model_rank = as.numeric(region_term),
      delta_aic  = aic - min(aic),
      # Choose the "best" ^ "simplest" model
      best_model = (model_rank == min(model_rank[delta_aic < 2]))
    ) %>%
    ungroup() 

  # Make pretty
  models_summary_printable <- models_summary %>%
    mutate(
      predictor = predictor %>%
        str_remove("_roughness") %>%
        str_replace_all("\\.", " ") %>%
        factor(levels = c(var_names, "PC1")),
      region_term = case_when(
        region_term == "none" ~ "None",
        region_term == "add"  ~ "Additive",
        region_term == "int"  ~ "Interaction",
      ),
      best_model = ifelse(best_model, "*", " ")
    ) %>%
    arrange(predictor) %>%
    mutate_at(c("slope_p_value", "region_p_value", "int_p_value"),
      ~ case_when(
        .x < 0.001 ~ "***",
        .x < 0.010 ~ "**",
        .x < 0.050 ~ "*",
        .x < 0.100 ~ ".",
        TRUE       ~ " "
      )
    ) %>%
    mutate_if(is.numeric, ~ case_when(
      is.na(.x) ~ " ",
      TRUE      ~ format(round(.x, digits = 2), nsmall = 2)
    )) %>%
    mutate_if(is.character, ~ ifelse(is.na(.x), " ", .x)) %>%
    dplyr::select(
      predictor, region_term, delta_aic, best_model,
      slope,        slope_p_value,
      region_coeff, region_p_value,
      int_coeff,    int_p_value
    )

  # Remove variable names after first mention in table
  models_summary_printable$predictor %<>% as.character()
  for (pred in unique(models_summary_printable$predictor)) {
    to_remove <- which(models_summary_printable$predictor == pred)[-1]
    models_summary_printable$predictor[to_remove] <- " "
  }
  
  # Print summary table
  response <- case_when(
    response == "HDS_richness"      ~ "$S_{\\mathrm{HDS}}$",
    response == "QDS_richness"      ~ "$S_{\\mathrm{QDS}}$",
    response == "add_turnover_prop" ~ "$T_{\\mathrm{QDS}} / S_{\\mathrm{HDS}}$"
  )
  knitr::kable(models_summary_printable,
    caption = glue(
      "Results of separate simple linear regressions of {response} \\
      against environmental heterogeneity variables. Asterisks beside each \\
      $\\Delta AIC$ denote the simples model with $\\Delta AIC < 2$. \\
      Asterisks beside regression coefficients denote $P$-values < 0.05, \\
      while periods (\".\") denote $P$-values > 0.05 but < 0.10."
    ),
    col.names = c(
      "Heterogeneity predictor", "Region-term",
      "$\\Delta AIC$", " ",
      "Slope",         " ",
      "SWAFR effect", " ",
      "Slope:SWAFR",  " "
    ),
    align = "llrlrlrlrl"
  )
}

```

\clearpage

```{r combined-region-HDS-richness-models}
combined_region_HDS_models <- fit_combined_region_models("HDS_richness")
check_region_effects_all_same(combined_region_HDS_models)
compare_combined_region_models(combined_region_HDS_models)
```

\clearpage

```{r combined-region-QDS-richness-models}
combined_region_QDS_models <- fit_combined_region_models("QDS_richness")
check_region_effects_all_same(combined_region_QDS_models)
compare_combined_region_models(combined_region_QDS_models)
```

<!--

### What Tony wants (`r Sys.Date()`)

Plotting the relationships of:

1. $S_HDS \sim MAP * region$
2. $S_HDS \sim NDVI + region$
3. $S_HDS \sim clay + region$
4. $S_QDS \sim PDQ * region$
5. $S_QDS \sim NDVI * region$
6. $S_QDS \sim soil C * region$

NOTE:

- For (1.), the interaction & main effects are both significant so the fitted slopes & intercepts need to be estimated separately for each region.
- For (2., 3.), only the main effects are significant, implying a common slope but different intercepts.
- For (4.--6.) The slopes and intercepts need to be estimated separately for the two regions.

{r plot-models-Tony-asked-for, fig.width=10}
m1 <- combined_region_HDS_models %>%
  filter(region_term == "int", predictor == "MAP_roughness") %>%
  pull(model)
m1[[1]]$data <- HDS
m1_plot <- visreg::visreg(m1[[1]],
  xvar    = "MAP_roughness",
  by      = "region",
  overlay = TRUE,
  gg      = TRUE
)

m2 <- combined_region_HDS_models %>%
  filter(region_term == "add", predictor == "NDVI_roughness") %>%
  pull(model)
m2[[1]]$data <- HDS
m2_plot <- visreg::visreg(m2[[1]],
  xvar    = "NDVI_roughness",
  by      = "region",
  overlay = TRUE,
  gg      = TRUE
)

m3 <- combined_region_HDS_models %>%
  filter(region_term == "add", predictor == "Clay_roughness") %>%
  pull(model)
m3[[1]]$data <- HDS
m3_plot <- visreg::visreg(m3[[1]],
  xvar    = "Clay_roughness",
  by      = "region",
  overlay = TRUE,
  gg      = TRUE
)

m4 <- combined_region_QDS_models %>%
  filter(region_term == "int", predictor == "PDQ_roughness") %>%
  pull(model)
m4[[1]]$data <- QDS
m4_plot <- visreg::visreg(m4[[1]],
  xvar    = "PDQ_roughness",
  by      = "region",
  overlay = TRUE,
  gg      = TRUE
)

m5 <- combined_region_QDS_models %>%
  filter(region_term == "int", predictor == "NDVI_roughness") %>%
  pull(model)
m5[[1]]$data <- QDS
m5_plot <- visreg::visreg(m5[[1]],
  xvar    = "NDVI_roughness",
  by      = "region",
  overlay = TRUE,
  gg      = TRUE
)

m6 <- combined_region_QDS_models %>%
  filter(region_term == "int", predictor == "Soil.C_roughness") %>%
  pull(model)
m6[[1]]$data <- QDS
m6_plot <- visreg::visreg(m6[[1]],
  xvar    = "Soil.C_roughness",
  by      = "region",
  overlay = TRUE,
  gg      = TRUE
)

m_plots <- list(
  m1_plot,
  m2_plot,
  m3_plot,
  m4_plot,
  m5_plot,
  m6_plot
)
m_legend <- get_legend(m_plots[[1]])
m_plots %<>% map(~ .x + theme(legend.position = "none"))
m_plots[1:3] %<>% map(~ .x + ylim(-100, 3100))
m_plots[4:6] %<>% map(~ .x + ylim(-100, 2600))

# Make points transparent manually
m_plots %<>% map(function(x) {
  x$layers[[3]]$aes_params$alpha <- 0.2
  x
})

plot_grid(
  plot_grid(plotlist = m_plots),
  m_legend,
  nrow = 1,
  rel_widths = c(1, 0.25)
)

-->

```{r plot-combined-region-PC1-models, fig.width=5, fig.height=6, fig.cap="The fits of the common regressions of (a) $S_{\\mathrm{HDS}}$ and (b) $S_{\\mathrm{QDS}}$ against each respective scale's PC1 scores (Table 4 and 5). Grey bands denote 95% confidence intervals."}
S_HDS_plot <- ggplot(HDS, aes(PC1, HDS_richness)) +
  geom_smooth(method = lm, colour = "black") +
  geom_point(aes(fill = region), shape = 21, colour = "black", stroke = 0.4) +
  ylab(bquote(italic("S")["HDS"])) +
  scale_fill_manual(name = "Region", values = c("black", NA)) +
  theme(
    legend.position = "none",
    axis.title.x    = element_blank(),
    axis.text.x     = element_blank(),
    axis.ticks.x    = element_blank(),
    axis.text.y     = element_text(angle = 90)
  )

translucent_white <- rgb(1, 1, 1, 0.5)
S_QDS_plot <- ggplot(QDS, aes(PC1, QDS_richness, colour = region)) +
  geom_smooth(method = lm, colour = "black") +
  geom_point(aes(fill = region), colour = "black", shape = 21) +
  ylab(bquote(italic("S")["QDS"])) +
  scale_fill_manual(name = "Region", values = c("black", translucent_white)) +
  theme(axis.text.y = element_text(angle = 90))

my_legend <- get_legend(S_QDS_plot)

S_QDS_plot <- S_QDS_plot +
  theme(legend.position = "none")

plot_grid(
  plot_grid(
    S_HDS_plot, S_QDS_plot,
    nrow = 2,
    rel_heights = c(0.9, 1),
    labels = c("(a)", "(b)")
  ),
  my_legend,
  nrow = 1,
  rel_widths = c(2, 1)
)
```
