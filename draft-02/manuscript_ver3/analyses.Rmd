---
title    : "Analyses & results"
subtitle : "GCFR vs SWAFR manuscript"
author   : "Ruan van Mazijk"
date     : "`r Sys.Date()`"
output   : [pdf_document, word_document]
geometry : a4paper, margin=1in
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo     = FALSE,
	fig.path = "figures/",
	message  = FALSE,
	warning  = FALSE
)
options(knitr.kable.NA = '')
library(here)
source(here("draft-02/manuscript_ver3/R/setup.R"))
```

# 1. Comparing environmental heterogeneity

```{r import-environmental-data}
data_dir <- here("data/derived-data/May-2019")
GCFR_file_names  <- glue("{data_dir}/GCFR_{var_names}_masked2.tif")
SWAFR_file_names <- glue("{data_dir}/SWAFR_{var_names}_masked2.tif")
GCFR_variables  <- stack(GCFR_file_names)
SWAFR_variables <- stack(SWAFR_file_names)
names(GCFR_variables)  <- str_replace_all(var_names, " ", "_")
names(SWAFR_variables) <- str_replace_all(var_names, " ", "_")
```

```{r plot-0.05-environmental-data, eval=FALSE}
# TODO: neaten these plots up for SI(?)
par(mfrow = c(3, 3))
plot(GCFR_variables)
par(op)

par(mfrow = c(3, 3))
plot(SWAFR_variables)
par(op)
```

```{r resample-environmental-data-from-0.05-to-EDS}
EDS_template_raster <- GCFR_variables$Elevation %>%
  aggregate(fact = 5) %>%  # aggregate up to QDS
  disaggregate(fact = 2)   # disaggregate down to EDS
GCFR_variables_EDS <- resample(
  GCFR_variables, EDS_template_raster,
  method = "bilinear"
)

EDS_template_raster <- SWAFR_variables$Elevation %>%
  aggregate(fact = 5) %>%
  disaggregate(fact = 2)
SWAFR_variables_EDS <- resample(
  SWAFR_variables, EDS_template_raster,
  method = "bilinear"
)
```

```{r plot-EDS-environmental-data, eval=FALSE}
# TODO: neaten these plots up for SI(?)
par(mfrow = c(3, 3))
plot(GCFR_variables_EDS)
par(op)

par(mfrow = c(3, 3))
plot(SWAFR_variables_EDS)
par(op)
```

```{r generate-heterogeneity-data}
scales <- c(1, 2, 4)

GCFR_heterogeneity <- map(scales,
  ~ GCFR_variables_EDS %>%
    aggregate(fact = .x) %>%
    aggregate(fun = var)
)
names(GCFR_heterogeneity) <- c("QDS", "HDS", "DS")
GCFR_heterogeneity %<>% {c(point1 = aggregate(GCFR_variables, fun = var), .)}

SWAFR_heterogeneity <- map(scales,
  ~ SWAFR_variables_EDS %>%
    aggregate(fact = .x) %>%
    aggregate(fun = var)
)
names(SWAFR_heterogeneity) <- c("QDS", "HDS", "DS")
SWAFR_heterogeneity %<>% {c(point1 = aggregate(SWAFR_variables, fun = var), .)}
```

```{r plot-heterogeneity-data, eval=FALSE}
# TODO: neaten these plots up for SI
par(mfrow = c(3, 3))
plot(GCFR_heterogeneity$point1)
par(op)

par(mfrow = c(3, 3))
plot(GCFR_heterogeneity$QDS)
par(op)

par(mfrow = c(3, 3))
plot(GCFR_heterogeneity$HDS)
par(op)

par(mfrow = c(3, 3))
plot(GCFR_heterogeneity$DS)
par(op)

par(mfrow = c(3, 3))
plot(SWAFR_heterogeneity$point1)
par(op)

par(mfrow = c(3, 3))
plot(SWAFR_heterogeneity$QDS)
par(op)

par(mfrow = c(3, 3))
plot(SWAFR_heterogeneity$HDS)
par(op)

par(mfrow = c(3, 3))
plot(SWAFR_heterogeneity$DS)
par(op)
```

```{r tidy-heterogeneity-data}
# Join regions' datasets
heterogeneity <- map2(GCFR_heterogeneity, SWAFR_heterogeneity,
  ~ na.exclude(rbind(
    cbind(region = "GCFR",  as.data.frame(log10(.x))),
    cbind(region = "SWAFR", as.data.frame(log10(.y)))
  ))
)
# Scale and centre all heterogeneity values _across_ regions
heterogeneity %<>%
  map(mutate_if, is.numeric, scale) %>%
  map(as_tibble)
```

```{r generate-PC1-of-EH}
heterogeneity_PCAs <- map(heterogeneity,
  ~ prcomp(
    .x[, -1], 
    center = TRUE, 
    scale. = TRUE
  )
)

# Force PC1 scores to be positive if all vars rotations are negative
heterogeneity_PCAs %<>% map(function(PCA) {
  if (all(PCA$rotation[, 1] <= 0)) {
    message("Multiplying this one by -1")
    PCA$rotation[, 1] %<>% multiply_by(-1)
    PCA$x[, 1]        %<>% multiply_by(-1)
  }
  PCA
})
```

```{r plot-PC1-of-EH, eval=FALSE}
# TODO: neaten this plot up for SI
heterogeneity_PCAs %>%
  map2(heterogeneity,
    ~ autoplot(.x, data = .y, colour = "region",
      alpha = 0.25,
      loadings       = TRUE, loadings.colour       = "black",
      loadings.label = TRUE, loadings.label.colour = "black",
      loadings.label.hjust = -0.25
    ) +
    ggtitle(unique(.y$scale)) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha = 0.5)
  ) %>%
  {plot_grid(plotlist = .)}
```

```{r add-PC1-to-heterogeneity-data}
PC1s <- map(heterogeneity_PCAs, ~tibble(PC1 = .x$x[, 1]))
heterogeneity %<>% map2(PC1s, ~as_tibble(cbind(.x, .y)))
```

```{r CLES-analysis}
heterogeneity_for_CLES <- list(
  GCFR = heterogeneity %>%
    map(filter, region == "GCFR") %>%
    map(dplyr::select, -region),
  SWAFR = heterogeneity %>%
    map(filter, region == "SWAFR") %>%
    map(dplyr::select, -region)
)
CLES_results <- heterogeneity_for_CLES %$%
  map2_dfr(GCFR, SWAFR, .id = "scale",
    # For every spatial scale, ...
    ~ map2_df(.x, .y, .id = "variable",
    # ... for every variable in each region, ...
      ~ tibble(
        # ... calculate the CLES, ...
        CLES_value = CLES(.y, .x),
        # ... & run a Mann-Whitney U-test.
        U_test = wilcox.test(.x, .y, conf.int = TRUE) %>% 
          tidy() %>%
          list()
      )
    )
  )
CLES_results %<>% mutate(
  variable = factor(variable, levels = var_names %>%
    str_replace_all(" ", "_") %>%
    c("PC1")
  ),
  scale = case_when(
    scale == "point1" ~ 0.10,
    scale == "QDS"    ~ 0.25,
    scale == "HDS"    ~ 0.50,
    scale == "DS"     ~ 1.00
  ),
  diff  = map_dbl(U_test, "estimate"),
  P_U   = map_dbl(U_test, "p.value"),
  U_low = map_dbl(U_test, "conf.low"),
  U_upp = map_dbl(U_test, "conf.high")
)
```

```{r fit-lms-of-CLES-vs-scale-for-each-variable}
CLES_models <- CLES_results %>%
  split(.$variable) %>%
  map(~lm(CLES_value ~ scale, .x))

# Summarise those models
CLES_model_summaries <- CLES_models %>%
  map_df(.id = "variable", tidy) %>%
  filter(term != "(Intercept)") %>%
  mutate(sig = case_when(
    p.value < 0.05 ~ "*",
    p.value < 0.10 ~ ".",
    TRUE            ~ " "
  )) %>%
  mutate(variable = factor(variable, levels = var_names %>%
    str_replace_all(" ", "_") %>%
    c("PC1")
  )) %>%
  mutate_if(is.numeric, round, digits = 3) %>%
  dplyr::select(variable, estimate, p.value, sig)
# Print table
knitr::kable(CLES_model_summaries,
  caption = paste(
    "Slopes of _CLES_ against ..."  # TODO
  ),
  col.names = c("Variable", "Slope", "_P_", " "),
  align = "lrrc"
)
```

```{r plot-heterogeneity-distributions, eval=FALSE}
# TODO: neaten this plot up for SI(?)
heterogeneity %>%  #heterogeneity_df %>%
  bind_rows(.id = "scale") %>%
  gather(
    variable, heterogeneity_value,
    -region, -scale#, -lon, -lat
  ) %>%
  mutate(variable = factor(variable, levels = var_names %>%
    str_replace_all(" ", "_") %>%
    c("PC1")
  )) %>%
  ggplot(aes(as.factor(scale), heterogeneity_value, fill = region)) +
    geom_boxplot() +
    facet_wrap(~variable, nrow = 2)
```

```{r plot-CLES, fig.cap="The common language effect size (_CLES_) of (a--i) various forms of environmental heterogeneity (log~10~-transformed) and (j) the major axis thereof (PC1) in the GCFR and SWAFR. The _CLES_ here is treated as the effect of GCFR relative to SWAFR values. Filled points represent comparisons where the GCFR and SWAFR significantly differed in heterogeneity (_P_ โค 0.05, Mann-Whitney U-tests), while unfilled points represent those that were not significant (_P_ > 0.05). Following simple linear regressions of CLES against scale, negative relationships (depicted by lines) were found for MAP (slope = -0.224, P = 0.028) and PC1 (slope = -0.076, P = 0.059). Abbreviations are as in Table 1."}
# Neaten variable labels to include panel letters
CLES_results %<>% mutate(
  variable = variable %>%
    as.character() %>%
    str_replace_all("_", " "),
  letters = rep(letters[1:10], 4),
  label = glue("({letters}) {variable}")
)
  
# Create empty panels
empty_plots <- ggplot(CLES_results, aes(scale, CLES_value)) +
  geom_hline(yintercept = 0.5, lty = "dashed") +
  facet_wrap(~label, nrow = 2) +
  scale_x_continuous(
    name   = "Scale (ยบ)",
    breaks = c(0.10, 0.25, 0.50, 1.00)
  ) +
  scale_y_continuous(
    name   = bquote(italic("CLES")~~~"(GCFR > SWAFR)") 
  ) +
  theme(
    legend.position = "none",
    axis.text.x     = element_text(angle = 90, vjust = 0.5),
    axis.text.y     = element_text(angle = 90, hjust = 0.5),
    strip.text.x    = element_text(hjust = 0)
  )
# Create dataset without data for NS regressions (above),
# so that geom_smooth() can't plot for those variables
sig_fits <- CLES_model_summaries %>%
  filter(sig != " ") %>%
  pull(variable) %>%
  str_replace_all("_", " ")
CLES_results_sans_NS <- CLES_results %>% mutate(
  CLES_value = ifelse(variable %in% sig_fits, CLES_value, NA)
)
# Add fits to empty plots
CLES_plots <- empty_plots +
  geom_smooth(
    data    = CLES_results_sans_NS,
    mapping = aes(group = label),
    method  = lm,
    se      = FALSE,
    colour  = "grey50"
  ) +
  # Plot full dataset on top of fits for clarity
  geom_point(data = CLES_results, aes(shape = P_U < 0.05), size = 2) +
  scale_shape_manual(values = c(1, 19))

CLES_plots
```

```{r plot-U-test-estimated-diffs, eval=FALSE}
# TODO: neaten this plot of SI
ggplot(CLES_results) +
  aes(scale, diff, group = variable) +
  geom_hline(yintercept = 0.0, lty = "dashed") +
  geom_line() +
  geom_errorbar(aes(ymin = U_low, ymax = U_upp), width = 0) +
  geom_point(aes(shape = P_U < 0.05)) +
  scale_shape_manual(name = bquote(italic("P"["U"]) < 0.05), values = c(1, 19))  +
  facet_wrap(~variable, nrow = 2)
```

# 2. Comparing species richness

```{r import-region-polygons, results="hide"}
GCFR_border  <- readOGR(here("data/derived-data/borders/GCFR_border"))
SWAFR_border <- readOGR(here("data/derived-data/borders/SWBP_Mike-Cramer"))

GCFR_border_buffered  <- readOGR(here("data/derived-data/borders/GCFR_border_buffered/"))
SWAFR_border_buffered <- readOGR(here("data/derived-data/borders/SWAFR_border_buffered/"))
ZA_QDS <- readOGR(here("data/raw-data/QDGC/qdgc_zaf"), layer = "qdgc_02_zaf")
AU_QDS <- readOGR(here("data/raw-data/QDGC/qdgc_aus"), layer = "qdgc_02_aus")

GCFR_box  <- readOGR(here("data/derived-data/borders/GCFR_box"))
SWAFR_box <- readOGR(here("data/derived-data/borders/SWAFR_box"))

# Import EDS polygons
ZA_EDS <- readOGR(here("data/raw-data/QDGC/qdgc_zaf"), layer = "qdgc_03_zaf")
AU_EDS <- readOGR(here("data/raw-data/QDGC/qdgc_aus"), layer = "qdgc_03_aus")

# Crop to regions
GCFR_EDS  <- crop(ZA_EDS, GCFR_box)
SWAFR_EDS <- crop(AU_EDS, SWAFR_box)

# Get DS, HDS, QDS codes from EDS codes
Larsen_grid <- rbind(GCFR_EDS, SWAFR_EDS)
Larsen_grid$edgc <- Larsen_grid$qdgc
Larsen_grid$qdgc <- str_remove(Larsen_grid$edgc, ".$")
Larsen_grid$hdgc <- str_remove(Larsen_grid$qdgc, ".$")
Larsen_grid$dgc  <- str_remove(Larsen_grid$hdgc, ".$")
```

```{r collate-heterogeneity-into-grids}
# Include lon/lat when converting from Raster* to data.frame
raster2df <- function(r) {
  lon_lat <- xyFromCell(r, 1:ncell(r))
  colnames(lon_lat) <- c("lon", "lat")
  df <- as.data.frame(log10(r))
  df <- cbind(lon_lat, df)
  df
}
heterogeneity_w_coords <- map2(GCFR_heterogeneity, SWAFR_heterogeneity,
  ~ na.exclude(rbind(
    cbind(region = "GCFR",  raster2df(.x)),
    cbind(region = "SWAFR", raster2df(.y))
  ))
)
heterogeneity_w_coords %<>% 
  map(mutate_at,
    vars(str_replace_all(var_names, " ", "_")), scale
  ) %>%
  map(as_tibble)
heterogeneity <- map2(heterogeneity, heterogeneity_w_coords, full_join)

heterogeneity$QDS$QDS <- heterogeneity$QDS %$%
  SpatialPoints(
    coords      = data.frame(x = lon, y = lat),
    proj4string = crs(Larsen_grid)
  ) %over%
  Larsen_grid %>%
  pull(qdgc)

heterogeneity$HDS$HDS <- heterogeneity$HDS %$%
  SpatialPoints(
    coords      = data.frame(x = lon, y = lat),
    proj4string = crs(Larsen_grid)
  ) %over%
  Larsen_grid %>%
  pull(hdgc)

heterogeneity$DS$DS <- heterogeneity$DS %$%
  SpatialPoints(
    coords      = data.frame(x = lon, y = lat),
    proj4string = crs(Larsen_grid)
  ) %over%
  Larsen_grid %>%
  pull(dgc) 
```

```{r collate-richness-into-grids}
make_SpatialPointsDataFrame <- function(x) {
  SpatialPointsDataFrame(
    coords      = x[, c("decimallongitude", "decimallatitude")],
    data        = x[, "species"],
    proj4string = crs(Larsen_grid)
  )
}
GCFR_species_occ <- make_SpatialPointsDataFrame(read_csv(here(
  "data/derived-data/flora",
  "GCFR_clean_flora_2017-09-14.csv"
)))
SWAFR_species_occ <- make_SpatialPointsDataFrame(read_csv(here(
  "data/derived-data/flora",
  "SWAFR_clean_flora_2017-09-14.csv"
)))
species_occ <- rbind(GCFR_species_occ, SWAFR_species_occ)

# Add grid codes to species data
species_occ$EDS <- species_occ %over%
  Larsen_grid %>%
  pull(edgc)
species_occ@data$EDS %<>% as.character()
species_occ$QDS <- str_remove(species_occ$EDS, ".$")
species_occ$HDS <- str_remove(species_occ$QDS, ".$")
species_occ$DS  <- str_remove(species_occ$HDS, ".$")

# Export final lists of species
GCFR_species_occ@data %>%
  group_by(species)  %>%
  summarise(n_collections = n()) %>%
  arrange(desc(n_collections)) %>%
  write_csv(here("draft-02/manuscript_ver3/GCFR-species.csv"))
SWAFR_species_occ@data %>%
  group_by(species) %>%
  summarise(n_collections = n()) %>%
  arrange(desc(n_collections)) %>%
  write_csv(here("draft-02/manuscript_ver3/SWAFR-species.csv"))

# Flag species w/ < 5 collections total in each region
GCFR_bad_species <-
  read_csv(here("draft-02/manuscript_ver3/GCFR-species.csv")) %>%
  filter(n_collections < 5) %>%
  pull(species)
SWAFR_bad_species <-
  read_csv(here("draft-02/manuscript_ver3/SWAFR-species.csv")) %>%
  filter(n_collections < 5) %>%
  pull(species)
# Filter them out
species_occ_data <- species_occ@data %>%
  filter(!(species %in% c(GCFR_bad_species, SWAFR_bad_species)))

species_occ_data %<>% na.exclude()

# Collate richness measures at each scale
# At QDS-scale:
QDS_richness <- species_occ_data %>%
  group_by(QDS) %>%
  summarise(
    n_EDS         = length(unique(EDS)),
    n_collections = length(species), 
    QDS_richness  = length(unique(species))
  )
# At HDS-scale:
mean_QDS_richness <- QDS_richness %>%
  mutate(HDS = str_remove(QDS, ".$")) %>%
  group_by(HDS) %>%
  summarise(mean_QDS_richness = mean(QDS_richness, na.rm = TRUE))
HDS_richness <- species_occ_data %>%
  group_by(HDS) %>%
  summarise(
    n_QDS         = length(unique(QDS)),
    n_collections = length(species),
    HDS_richness  = length(unique(species))
  ) %>%
  full_join(mean_QDS_richness)
# At DS-scale:
mean_HDS_richness <- HDS_richness %>%
  mutate(DS = str_remove(HDS, ".$")) %>%
  group_by(DS) %>%
  summarise(mean_HDS_richness = mean(HDS_richness, na.rm = TRUE))
DS_richness <- species_occ_data %>%
  group_by(DS) %>%
  summarise(
    n_HDS         = length(unique(HDS)),
    n_collections = length(species),
    DS_richness   = length(unique(species))
  ) %>%
  full_join(mean_HDS_richness)
```

```{r collate-gridded-heterogeneity-and-richness}
data <- heterogeneity[-1]  # can't use 0.10x0.10 for richness data
data$QDS %<>%
  full_join(QDS_richness) %>%
  na.exclude() #%>%
  #filter(n_EDS == 4)
data$HDS %<>%
  full_join(HDS_richness) %>%
  na.exclude() %>%
  #filter(n_QDS == 4) %>%
  mutate(
    QDS_turnover      = HDS_richness - mean_QDS_richness,
    QDS_turnover_prop = QDS_turnover / HDS_richness
  )
data$DS %<>%
  full_join(DS_richness) %>%
  na.exclude() %>%
  filter(n_HDS == 4) %>%
  mutate(
    HDS_turnover      = DS_richness - mean_HDS_richness,
    HDS_turnover_prop = HDS_turnover/DS_richness,
  )
```

```{r explore-collection-effort, eval=FALSE}
ggplot(data$QDS, aes(QDS_richness, n_collections, colour = region)) +
  geom_abline(intercept = 0, slope = 1) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10()
ggplot(data$HDS, aes(HDS_richness, n_collections, colour = region)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10()
ggplot(data$DS, aes(DS_richness, n_collections, colour = region)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10()

ggplot(data$QDS) +
  aes(n_collections, n_collections/QDS_richness, colour = region) +
  geom_smooth(method = lm) +
  geom_point() +
  labs(
    x = "No. collections in QDS", 
    y = "No. collections per species in QDS"
  ) +
  scale_x_log10() +
  scale_y_log10()
ggplot(data$QDS) +
  aes(QDS_richness, n_collections*QDS_richness, colour = region) +
  geom_point()

ggplot(data$HDS) +
  aes(n_collections, HDS_richness, colour = region) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1) +
  lims(x = c(0, 2e4), y = c(0, 2e4))

size_of_choice <- function(n = 100) {
  d <- data.frame(x = 1:n)
  d$y <- choose(n, d$x)
  plot(y ~ x, d,type = "l")
}
size_of_choice()

1:nrow(data$HDS) %>%
  map_dfr(.id = "sample_size", ~sample_n(data$HDS, .x)) %>%
  group_by(region, sample_size) %>%
  summarise(HDS_richness = mean(HDS_richness)) %>%
  ungroup() %>%
  mutate(sample_size = as.numeric(as.character(sample_size))) %>%
  ggplot(aes(sample_size, HDS_richness, colour = region)) +
    geom_point()

ggplot(data$QDS) +
  aes(n_collections, QDS_richness/n_collections, colour = region) +
  geom_point() +
  labs(
    x = "No. collections in QDS", 
    y = "No. species per collection in QDS"
  ) +
  scale_x_log10()

ggplot(data$HDS) +
  aes(n_collections, HDS_richness/n_collections, colour = region) +
  geom_point() +
  labs(
    x = "No. collections in HDS", 
    y = "No. species per collection in HDS"
  ) +
  scale_x_log10()

ggplot(data$DS) +
  aes(n_collections, DS_richness/n_collections, colour = region) +
  geom_point() +
  labs(
    x = "No. collections in DS", 
    y = "No. species per collection in DS"
  ) +
  scale_x_log10()

ggplot(data$QDS, aes(QDS_richness/n_collections, fill = region)) +
  geom_histogram(position = "dodge")
ggplot(data$HDS, aes(HDS_richness/n_collections, fill = region)) +
  geom_histogram(position = "dodge")
ggplot(data$DS, aes(DS_richness/n_collections, fill = region)) +
  geom_histogram(position = "dodge")

data %$%
  HDS %>%
  mutate(QDS_turnover_std =
    ((HDS_richness/n_collections) - (mean_QDS_richness/n_collections)) #/
    #(HDS_richness/n_collections)
  ) %>%
  ggplot(aes(QDS_turnover_std, fill = region)) +
    geom_histogram(position = "dodge")

ggplot(data$QDS, aes(lon, lat, colour = n_collections)) +
  geom_point(size = 3) +
  facet_grid(~region, scales = "free_x") +
  scale_colour_viridis_c()
ggplot(data$HDS, aes(lon, lat, colour = n_collections)) +
  geom_point(size = 5) +
  facet_grid(~region, scales = "free_x") +
  scale_colour_viridis_c()
ggplot(data$DS, aes(lon, lat, colour = n_collections)) +
  geom_point(size = 10) +
  facet_grid(~region, scales = "free_x") +
  scale_colour_viridis_c()
```

```{r plot-richness-distributions-and-partitions, fig.width=7, fig.height=6, fig.cap="Distributions of (a) QDS- and (b) HDS-scale vascular plant species richness in the GCFR and SWAFR. (c) Scatter plot of mean QDS-scale richness ($\\overline{S}$~QDS~) and turnover (_T_~QDS~; Equation 1) with contour lines denoting the _S_~HDS~ that arises as their sum. (d) The distribution of the turnover partition of _S_~HDS~ (_T_~QDS~; in c) expressed as a proportion (_T_~QDS~ / $\\overline{S}$~HDS~)."}
data_for_plot <- data %$%
  rbind(
    QDS %>%
      dplyr::select(region, QDS_richness) %>%
      rename(richness = QDS_richness) %>%
      add_column(scale = "QDS", turnover_prop = NA),
    HDS %>%
      dplyr::select(region, HDS_richness, QDS_turnover_prop) %>%
      rename(richness = HDS_richness, turnover_prop = QDS_turnover_prop) %>%
      add_column(scale = "HDS"),
    DS %>%
      dplyr::select(region, DS_richness, HDS_turnover_prop) %>%
      rename(richness = DS_richness, turnover_prop = HDS_turnover_prop) %>%
      add_column(scale = "DS")
  ) %>%
  as_tibble() %>%
  gather(metric, metric_value, richness, turnover_prop) %>%
  unite(metric_scale, scale, metric) %>%
  na.exclude()

x_axis_labels <- list(
  QDS_richness      = bquote(italic("S")["QDS"]),
  HDS_richness      = bquote(italic("S")["HDS"]),
  HDS_turnover_prop = bquote(italic("T")["QDS"]/bar(italic("S"))["QDS"]),
  DS_richness       = bquote(italic("S")["DS"]),
  DS_turnover_prop  = bquote(italic("T")["HDS"]/bar(italic("S"))["HDS"])
)
hist_plots <- map(unique(data_for_plot$metric_scale),
  ~ data_for_plot %>%
    filter(metric_scale == .x) %>%
    ggplot(aes(metric_value, fill = region)) +
      geom_histogram(
        bins = case_when(
          str_detect(.x, "QDS") ~ 30,
          str_detect(.x, "HDS") ~ 20,
          str_detect(.x, "DS")  ~ 10
        ),
        position = "dodge",
        colour = "black"
      ) +
      scale_fill_manual(name = "Region", values = c("black", "white")) +
      labs(
        x = x_axis_labels[[.x]],
        y = case_when(
          str_detect(.x, "QDS") ~ "No. QDS",
          str_detect(.x, "HDS") ~ "No. HDS",
          str_detect(.x, "DS")  ~ "No. DS"
        )
      ) +
      theme(
        legend.position = c(0.8, 0.8),
        axis.text.y     = element_text(angle = 90, hjust = 0.5)
      )
)
names(hist_plots) <- unique(data_for_plot$metric_scale)

plot_lim <- data %$%
  HDS %$%
  ceiling(max(c(mean_QDS_richness, QDS_turnover))) + 10
S_HDS_background <- plot_lim %>%
  {seq(from = 0, to = ., by = 10)} %>%
  {expand.grid(x = ., y = .)} %>%
  mutate(z = x + y)
S_HDS_background_plot <- ggplot(S_HDS_background) +
  lims(x = c(0, plot_lim), y = c(0, plot_lim)) +
  geom_contour(
    mapping     = aes(x, y, z = z),
    binwidth    = 500,
    colour      = "grey90",
    show.legend = TRUE
  ) +
  geom_abline(
    intercept = 0, slope = 1,
    linetype = "dashed", colour = "grey25"
  ) +
  labs(
    x = bquote(italic("T")["QDS"]),
    y = bquote(bar(italic("S"))["QDS"])
  ) +
  theme(axis.text.y = element_text(angle = 90, hjust = 0.5))

partition_plot <- S_HDS_background_plot +
  geom_point(
    data    = data$HDS,
    mapping = aes(QDS_turnover, mean_QDS_richness, fill = region),
    shape   = 21
  ) +
  scale_fill_manual(values = c("black", "white")) +
  theme(legend.position = "none")

# Add labels to S_HDS contours manually
label1500 <- bquote(italic("S")["HDS"] == 1500)
partition_plot <- partition_plot +
  geom_text(
    data = tibble(
      add_turnover      = c( 10,   10,        60,  560, 1060),
      mean_QDS_richness = c(500, 1000,      1450, 1500, 1500),
      HDS_richness      = c(500, 1000, label1500, 2000, 2500)
    ),
    mapping = aes(add_turnover, mean_QDS_richness, label = HDS_richness),
    angle = -45, vjust = -0.5, colour = "grey50", size = 2.5,
    parse = TRUE
  ) +
  # Flip partition plot to get axes to line up across panels (b/o text heights)
  coord_flip()

hist_plots[c("QDS_richness", "HDS_turnover_prop")] %<>% map(
  ~.x + theme(legend.position = "none")
)
# Plot panels
hist_plots %$% plot_grid(
  QDS_richness,   HDS_richness,
  partition_plot, HDS_turnover_prop,
  nrow = 2,
  labels = glue("({letters[1:4]})"),
  label_x = 0.125, label_y = 0.975
)
# TODO: Plot DS-scale versions for SI
```

```{r tests-of-richness-etc}
richness_test_results <- data %$% rbind(
  QDS %$% tibble(
    metric = "QDS_richness",
    P_U = tidy(wilcox.test(QDS_richness ~ region))$p.value,
    CLES_value = CLES(
      QDS_richness[region == "SWAFR"],
      QDS_richness[region == "GCFR"]
    )
  ),
  HDS %$% tibble(
    metric = "HDS_richness", 
    P_U = tidy(wilcox.test(HDS_richness ~ region))$p.value,
    CLES_value = CLES(
      HDS_richness[region == "SWAFR"],
      HDS_richness[region == "GCFR"]
    )
  ),
  DS %$% tibble(
    metric = "DS_richness", 
    P_U = tidy(wilcox.test(DS_richness ~ region))$p.value,
    CLES_value = CLES(
      DS_richness[region == "SWAFR"],
      DS_richness[region == "GCFR"]
    )
  ),
  HDS %$% tibble(
    metric = "QDS_turnover_prop", 
    P_U = tidy(wilcox.test(QDS_turnover_prop ~ region))$p.value,
    CLES_value = CLES(
      QDS_turnover_prop[region == "SWAFR"],
      QDS_turnover_prop[region == "GCFR"]
    )
  ),
  DS %$% tibble(
    metric = "HDS_turnover_prop", 
    P_U = tidy(wilcox.test(HDS_turnover_prop ~ region))$p.value,
    CLES_value = CLES(
      HDS_turnover_prop[region == "SWAFR"],
      HDS_turnover_prop[region == "GCFR"]
    )
  )
)
# Print table
knitr::kable(richness_test_results,
  caption = paste(
    "..."
  )
)
```

```{r, eval=FALSE}
#data %>%
#  map(~split(.x, .x$region))
#  QDS %>%
#  filter(region == "GCFR")
#QDS_GCFR_pts <- SpatialPointsDataFrame(
#  coords      = data_QDS_GCFR %>% dplyr::select(lon, lat),
#  data        = data_QDS_GCFR %>% dplyr::select(-region, -QDS, -lon, -lat),
#  proj4string = crs(Larsen_grid)
#)
#QDS_GCFR_ras <- rasterize(QDS_GCFR_pts, GCFR_heterogeneity$QDS)
#autoplot(QDS_GCFR_ras$QDS_richness) +
#  scale_fill_viridis_c()

data_QDS_GCFR <- data %$%
  QDS %>%
  filter(region == "GCFR")
QDS_GCFR_pts <- SpatialPixelsDataFrame(SpatialPoints(
  coords      = data_QDS_GCFR %>%
                  dplyr::select(lon, lat) %>%
                  mutate(lon = lon - 0.075 - 0.125, lat = lat + 0.025 + 0.125),
  proj4string = crs(Larsen_grid)),
  data        = data_QDS_GCFR %>% dplyr::select(-region, -QDS, -lon, -lat)
)
autoplot(QDS_GCFR_pts) +
  geom_path(
    data = ZA_QDS,
    aes(long, lat, group = group),
    color = "black", size = 0.5
  ) +
  scale_fill_viridis_c(na.value = NA) +
  labs(x = "Longitude (ยบ)", y = "Latitude (ยบ)")

QDS_GCFR_ras <- rasterize(QDS_GCFR_pts, GCFR_heterogeneity$QDS)
gplot(QDS_GCFR_ras$QDS_richness) +
  geom_tile(aes(fill = value)) +
  geom_path(
    data = ZA_QDS,
    aes(long, lat, group = group),
    color = "black", size = 0.5
  ) +
  scale_fill_viridis_c(na.value = NA) +
  labs(x = "Longitude (ยบ)", y = "Latitude (ยบ)")

#plot(QDS_GCFR_ras$QDS_richness)
plot(QDS_GCFR_pts)
plot(ZA_QDS, add = TRUE)
#plot(GCFR_border, add = TRUE)
#plot(GCFR_EDS, add = TRUE)

data_QDS_SWAFR <- data %$%
  QDS %>%
  filter(region == "SWAFR")
QDS_SWAFR_pts <- SpatialPointsDataFrame(
  coords      = data_QDS_SWAFR %>% dplyr::select(lon, lat),
  data        = data_QDS_SWAFR %>% dplyr::select(-region, -QDS, -lon, -lat),
  proj4string = crs(Larsen_grid)
)
QDS_SWAFR_ras <- rasterize(QDS_SWAFR_pts, SWAFR_heterogeneity$QDS)
autoplot(QDS_SWAFR_ras$QDS_richness)

data_HDS_GCFR <- data %$%
  HDS %>%
  filter(region == "GCFR")
HDS_GCFR_pts <- SpatialPointsDataFrame(
  coords      = data_HDS_GCFR %>% dplyr::select(lon, lat),
  data        = data_HDS_GCFR %>% dplyr::select(-region, -HDS, -lon, -lat),
  proj4string = crs(Larsen_grid)
)
HDS_GCFR_ras <- rasterize(HDS_GCFR_pts, GCFR_heterogeneity$HDS)
plot(HDS_GCFR_ras$HDS_richness)
plot(GCFR_border, add = TRUE)
plot(GCFR_border_buffered, add = TRUE)
plot(ZA_EDS, add = TRUE)

data_HDS_SWAFR <- data %$%
  HDS %>%
  filter(region == "SWAFR")
HDS_SWAFR_pts <- SpatialPointsDataFrame(
  coords      = data_HDS_SWAFR %>% dplyr::select(lon, lat),
  data        = data_HDS_SWAFR %>% dplyr::select(-region, -HDS, -lon, -lat),
  proj4string = crs(Larsen_grid)
)
HDS_SWAFR_ras <- rasterize(HDS_SWAFR_pts, SWAFR_heterogeneity$HDS)
autoplot(HDS_SWAFR_ras$HDS_richness)
```

```{r maps, eval=FALSE}
ggplot(data$QDS, aes(lon, lat, colour = QDS_richness)) +
  geom_tile() +
  facet_grid(~region, scales = "free_x") +
  scale_colour_viridis_c()
ggplot(data$HDS, aes(lon, lat, colour = HDS_richness)) +
  geom_point(size = 5) +
  facet_grid(~region, scales = "free_x") +
  scale_colour_viridis_c()
ggplot(data$DS, aes(lon, lat, colour = DS_richness)) +
  geom_point(size = 10) +
  facet_grid(~region, scales = "free_x") +
  scale_colour_viridis_c()

ggplot(data$QDS, aes(lon, lat, colour = PC1)) +
  geom_point(size = 3) +
  facet_grid(~region, scales = "free_x") +
  scale_colour_viridis_c()
ggplot(data$HDS, aes(lon, lat, colour = PC1)) +
  geom_point(size = 5) +
  facet_grid(~region, scales = "free_x") +
  scale_colour_viridis_c()
ggplot(data$DS, aes(lon, lat, colour = PC1)) +
  geom_point(size = 10) +
  facet_grid(~region, scales = "free_x") +
  scale_colour_viridis_c()

ggplot(data$QDS, aes(lon, lat, colour = PC1_residual)) +
  geom_point(size = 3) +
  facet_grid(~region, scales = "free_x") +
  scale_colour_viridis_c()
ggplot(data$HDS, aes(lon, lat, colour = PC1_residual)) +
  geom_point(size = 5) +
  facet_grid(~region, scales = "free_x") +
  scale_colour_viridis_c()
ggplot(data$DS, aes(lon, lat, colour = PC1_residual)) +
  geom_point(size = 10) +
  facet_grid(~region, scales = "free_x") +
  scale_colour_viridis_c()
```

# 3. Environmental heterogeneity as an explanation of species richness

## 3.1. Univariate models

```{r fit-PC1-models, results="hide"}
# QDS-richness:
m1 <- lm(      QDS_richness  ~ PC1, data$QDS)
m2 <- lm(  log(QDS_richness) ~ PC1, data$QDS)
m3 <- lm(log10(QDS_richness) ~ PC1, data$QDS)
AIC(m1, m2, m3) %>%
  mutate(delta_AIC  = AIC - min(AIC))
# Choose m3 (log10)
m4 <- lm(log10(QDS_richness) ~ PC1 + region, data$QDS)
m5 <- lm(log10(QDS_richness) ~ PC1 * region, data$QDS)
AIC(m3, m4, m5) %>%
  mutate(delta_AIC  = AIC - min(AIC))
# Choose m3 still (heterogeneity main effect only)
summary(m3)  # R^2 = 0.07619
# Store residuals in master dataset for use in maps below
data$QDS$PC1_residual <- m3$residuals

# HDS-richness:
m1 <- lm(      HDS_richness  ~ PC1, data$HDS)
m2 <- lm(  log(HDS_richness) ~ PC1, data$HDS)
m3 <- lm(log10(HDS_richness) ~ PC1, data$HDS)
AIC(m1, m2, m3) %>%
  mutate(delta_AIC  = AIC - min(AIC))
# Choose m3 (log10)
m4 <- lm(log10(HDS_richness) ~ PC1 + region, data$HDS)
m5 <- lm(log10(HDS_richness) ~ PC1 * region, data$HDS)
AIC(m3, m4, m5) %>%
  mutate(delta_AIC  = AIC - min(AIC))
# Choose m3 (heterogeneity main effect only)
summary(m3)  # R^2 = 0.1024
# Store residuals in master dataset for use in maps below
data$HDS$PC1_residual <- m3$residuals

# DS-richness:
m1 <- lm(      DS_richness  ~ PC1, data$DS)
m2 <- lm(  log(DS_richness) ~ PC1, data$DS)
m3 <- lm(log10(DS_richness) ~ PC1, data$DS)
AIC(m1, m2, m3) %>%
  mutate(delta_AIC  = AIC - min(AIC))
# Choose m3 (log10)
m4 <- lm(log10(DS_richness) ~ PC1 + region, data$DS)
m5 <- lm(log10(DS_richness) ~ PC1 * region, data$DS)
AIC(m3, m4, m5) %>%
  mutate(delta_AIC  = AIC - min(AIC))
# Choose m3 (heterogeneity main effect only)
summary(m3)  # R^2 = 0.3473
# Store residuals in master dataset for use in maps below
data$DS$PC1_residual <- m3$residuals
```

```{r plot-PC1-models, fig.width=7, fig.height=3, fig.cap="..."}
PC1_explained_var <- heterogeneity_PCAs[2:4] %>%
  map(summary) %>%
  map("importance") %>%
  map(~.x[2, "PC1"]) %>%
  map(multiply_by, 100) %>%
  map(round, digits = 2)

data_for_PC1_plots <- 
  rbind(
    cbind(scale = "QDS", data %$%
      QDS %>%
      dplyr::select(region, QDS_richness, PC1) %>%
      rename(richness = QDS_richness)
    ),
    cbind(scale = "HDS", data %$%
      HDS %>%
      dplyr::select(region, HDS_richness, PC1) %>%
      rename(richness = HDS_richness)
    ),
    cbind(scale = "DS", data %$%
      DS %>%
      dplyr::select(region, DS_richness, PC1) %>%
      rename(richness = DS_richness)
    )
  ) %>%
  as_tibble() %>%
  mutate(scale = case_when(
    scale == "QDS" ~ bquote("(a)~QDS~~(italic(R)^2 == '0.08')"),
    scale == "HDS" ~ bquote("(b)~HDS~~(italic(R)^2 == '0.10')"),
    scale == "DS"  ~ bquote("(c)~DS~~(italic(R)^2 == '0.35')")
  ))
translucent_white <- rgb(1, 1, 1, 0.5)
ggplot(data_for_PC1_plots, aes(PC1, richness)) +
  geom_point(aes(fill = region), shape = 21, colour = "black") +
  geom_smooth(method = lm, colour = "black") +
  ylab(bquote(italic("S"))) +
  xlab(paste0(
    "PC1 (", PC1_explained_var$QDS, "%)                              ",
    "PC1 (", PC1_explained_var$HDS, "%)                              ",
    "PC1 (", PC1_explained_var$DS,  "%)"
  )) +
  scale_y_log10() +
  scale_fill_manual(name = "Region", values = c("black", translucent_white)) +
  facet_grid(~scale, scales = "free_x", labeller = label_parsed) +
  theme(
    legend.position   = c(0.9, 0.2), 
    legend.background = element_rect(fill = NA),
    axis.text.y       = element_text(angle = 90, hjust = 0.5),
    strip.text        = element_text(hjust = 0)
  )
```

```{r check-for-scale-dependence-formally-w-ANCOVA, results="hide"}
m1 <- lm(log10(richness) ~ PC1,         data_for_PC1_plots)
m2 <- lm(log10(richness) ~ PC1 + scale, data_for_PC1_plots)
m3 <- lm(log10(richness) ~ PC1 * scale, data_for_PC1_plots)
AIC(m1, m2, m3) %>%
  mutate(delta_AIC  = AIC - min(AIC))
# No evidence for interaction, only differing intercepts!
summary(m2)
visreg::visreg(m2,
  trans   = function(x) 10^x,
  xvar    = "PC1",
  by      = "scale",
  overlay = TRUE,
  gg      = TRUE, 
  rug     = FALSE,
  ylab    = bquote(italic("S"))
) +
  theme(legend.position = "none")
```

```{r fit-univariate-QDS-richness-models}
predictor_names <- c(str_replace_all(var_names, " ", "_"), "PC1")

univar_models <- map(predictor_names,
  ~ list(
    non_region = lm(paste("log10(QDS_richness) ~", .x),             data$QDS),
    add_region = lm(paste("log10(QDS_richness) ~", .x, "+ region"), data$QDS),
    int_region = lm(paste("log10(QDS_richness) ~", .x, "* region"), data$QDS)
  )
)
names(univar_models) <- predictor_names

univar_model_summary <- univar_models %>%
  map_dfr(.id = "variable",
    ~ tibble(
      model_type = names(.x),
      model_rank = 1:3,
      model = .x
    )
  ) %>%
  group_by(variable) %>%
  mutate(
    slope        = map_dbl(model, ~tidy(.x)$estimate[2]),
    P_slope      = map_dbl(model, ~tidy(.x)$p.value[ 2]),
    region_coeff = map2_dbl(model, model_type,
                     ~ ifelse(.y != "non_region",
                       tidy(.x)$estimate[3],
                       NA
                     )
                   ),
    P_region     = map2_dbl(model, model_type,
                     ~ ifelse(.y != "non_region",
                       tidy(.x)$p.value[3],
                       NA
                     )
                   ),
    int_coeff    = map2_dbl(model, model_type,
                     ~ ifelse(.y == "int_region",
                       tidy(.x)$estimate[4],
                       NA
                     )
                   ),
    P_int        = map2_dbl(model, model_type,
                     ~ ifelse(.y == "int_region",
                       tidy(.x)$p.value[4],
                       NA
                     )
                   ),
    slope_sig    = ifelse(P_slope  < 0.05, "*", ""),
    region_sig   = ifelse(P_region < 0.05, "*", ""),
    int_sig      = ifelse(P_int    < 0.05, "*", ""),
    AIC          = map_dbl(model, AIC),
    delta_AIC    = AIC - min(AIC),
    best_model   = (model_rank == min(model_rank[delta_AIC < 2]))
  ) %>%
  filter(best_model) %>%
  ungroup() %>%
  mutate(
    model_type = 
      case_when(
        model_type == "non_region"                   ~ "Main effect only",
        model_type == "add_region" & P_slope <  0.05 ~ "Main effect + region",
        model_type == "add_region" & P_slope >= 0.05 ~ "Region only",
        model_type == "int_region"                   ~ "Main effect * region"
      ) %>%
      factor(levels = c(
        "Main effect * region",
        "Main effect + region",
        "Main effect only",
        "Region only"
      )),
    variable = str_replace_all(variable, "_", " "),
    slope_sign  = ifelse(slope        > 0, "+", "-"),
    region_sign = ifelse(region_coeff > 0, "+", "-"),
    int_sign    = ifelse(int_coeff    > 0, "+", "-")
  ) %>%
  mutate_at(c("P_slope", "P_region", "P_int"),
    ~ case_when(
      .x < 0.001 ~ "***",
      .x < 0.010 ~ "**",
      .x < 0.050 ~ "*",
      .x < 0.100 ~ ".",
      TRUE       ~ " "
    )
  ) %>%
  mutate_if(is.character, ~ ifelse(is.na(.x), " ", .x)) %>%
  dplyr::select(
    model_type,  variable,
    slope_sign,  P_slope,
    region_sign, P_region,
    int_sign,    P_int
  ) %>%
  arrange(model_type)
  
# Remove variable names after first mention in table
univar_model_summary$model_type %<>% as.character()
for (pred in unique(univar_model_summary$model_type)) {
  to_remove <- which(univar_model_summary$model_type == pred)[-1]
  univar_model_summary$model_type[to_remove] <- " "
}

# No interaction models best-fitting, so remove those columns
univar_model_summary %<>% dplyr::select(-int_sign, -P_int)

# Print summary table
knitr::kable(univar_model_summary,
  caption = paste(
    "Summarised results of the best fitting separate simple linear",
    "regressions of log~10~[_S_~QDS~] against environmental heterogeneity."
  ),
  col.names = c(
    "Model type",   "Heterogeneity predictor",
    "Slope",        " ",
    "SWAFR effect", " "
  ),
  align = "llclcl"
)
```

```{r fit-univariate-HDS-richness-models}
univar_models <- map(predictor_names,
  ~ list(
    non_region = lm(paste("log10(HDS_richness) ~", .x),             data$HDS),
    add_region = lm(paste("log10(HDS_richness) ~", .x, "+ region"), data$HDS),
    int_region = lm(paste("log10(HDS_richness) ~", .x, "* region"), data$HDS)
  )
)
names(univar_models) <- predictor_names

univar_model_summary <- univar_models %>%
  map_dfr(.id = "variable",
    ~ tibble(
      model_type = names(.x),
      model_rank = 1:3,
      model = .x
    )
  ) %>%
  group_by(variable) %>%
  mutate(
    slope        = map_dbl(model, ~tidy(.x)$estimate[2]),
    P_slope      = map_dbl(model, ~tidy(.x)$p.value[ 2]),
    region_coeff = map2_dbl(model, model_type,
                     ~ ifelse(.y != "non_region",
                       tidy(.x)$estimate[3],
                       NA
                     )
                   ),
    P_region     = map2_dbl(model, model_type,
                     ~ ifelse(.y != "non_region",
                       tidy(.x)$p.value[3],
                       NA
                     )
                   ),
    int_coeff    = map2_dbl(model, model_type,
                     ~ ifelse(.y == "int_region",
                       tidy(.x)$estimate[4],
                       NA
                     )
                   ),
    P_int        = map2_dbl(model, model_type,
                     ~ ifelse(.y == "int_region",
                       tidy(.x)$p.value[4],
                       NA
                     )
                   ),
    slope_sig    = ifelse(P_slope  < 0.05, "*", ""),
    region_sig   = ifelse(P_region < 0.05, "*", ""),
    int_sig      = ifelse(P_int    < 0.05, "*", ""),
    AIC          = map_dbl(model, AIC),
    delta_AIC    = AIC - min(AIC),
    best_model   = (model_rank == min(model_rank[delta_AIC < 2]))
  ) %>%
  filter(best_model) %>%
  ungroup() %>%
  mutate(
    model_type = 
      case_when(
        model_type == "non_region"                   ~ "Main effect only",
        model_type == "add_region" & P_slope <  0.05 ~ "Main effect + region",
        model_type == "add_region" & P_slope >= 0.05 ~ "Region only",
        model_type == "int_region"                   ~ "Main effect * region"
      ) %>%
      factor(levels = c(
        "Main effect * region",
        "Main effect + region",
        "Main effect only",
        "Region only"
      )),
    variable = str_replace_all(variable, "_", " "),
    slope_sign  = ifelse(slope        > 0, "+", "-"),
    region_sign = ifelse(region_coeff > 0, "+", "-"),
    int_sign    = ifelse(int_coeff    > 0, "+", "-")
  ) %>%
  mutate_at(c("P_slope", "P_region", "P_int"),
    ~ case_when(
      .x < 0.001 ~ "***",
      .x < 0.010 ~ "**",
      .x < 0.050 ~ "*",
      .x < 0.100 ~ ".",
      TRUE       ~ " "
    )
  ) %>%
  mutate_if(is.character, ~ ifelse(is.na(.x), " ", .x)) %>%
  dplyr::select(
    model_type,  variable,
    slope_sign,  P_slope,
    region_sign, P_region,
    int_sign,    P_int
  ) %>%
  arrange(model_type)
  
# Remove variable names after first mention in table
univar_model_summary$model_type %<>% as.character()
for (pred in unique(univar_model_summary$model_type)) {
  to_remove <- which(univar_model_summary$model_type == pred)[-1]
  univar_model_summary$model_type[to_remove] <- " "
}

# All main effect only best-fitting, so remove other columns
univar_model_summary %<>% dplyr::select(
  -region_sign, -P_region, 
  -int_sign,    -P_int
)

# Print summary table
knitr::kable(univar_model_summary,
  caption = paste(
    "Summarised results of the best fitting separate simple linear",
    "regressions of log~10~[_S_~HDS~] against environmental heterogeneity."
  ),
  col.names = c(
    "Model type", "Heterogeneity predictor",
    "Slope",      " "
  ),
  align = "llcl"
)
```

```{r fit-univariate-DS-richness-models}
univar_models <- map(predictor_names,
  ~ list(
    non_region = lm(paste("log10(DS_richness) ~", .x),             data$DS),
    add_region = lm(paste("log10(DS_richness) ~", .x, "+ region"), data$DS),
    int_region = lm(paste("log10(DS_richness) ~", .x, "* region"), data$DS)
  )
)
names(univar_models) <- predictor_names

univar_model_summary <- univar_models %>%
  map_dfr(.id = "variable",
    ~ tibble(
      model_type = names(.x),
      model_rank = 1:3,
      model = .x
    )
  ) %>%
  group_by(variable) %>%
  mutate(
    slope        = map_dbl(model, ~tidy(.x)$estimate[2]),
    P_slope      = map_dbl(model, ~tidy(.x)$p.value[ 2]),
    region_coeff = map2_dbl(model, model_type,
                     ~ ifelse(.y != "non_region",
                       tidy(.x)$estimate[3],
                       NA
                     )
                   ),
    P_region     = map2_dbl(model, model_type,
                     ~ ifelse(.y != "non_region",
                       tidy(.x)$p.value[3],
                       NA
                     )
                   ),
    int_coeff    = map2_dbl(model, model_type,
                     ~ ifelse(.y == "int_region",
                       tidy(.x)$estimate[4],
                       NA
                     )
                   ),
    P_int        = map2_dbl(model, model_type,
                     ~ ifelse(.y == "int_region",
                       tidy(.x)$p.value[4],
                       NA
                     )
                   ),
    slope_sig    = ifelse(P_slope  < 0.05, "*", ""),
    region_sig   = ifelse(P_region < 0.05, "*", ""),
    int_sig      = ifelse(P_int    < 0.05, "*", ""),
    AIC          = map_dbl(model, AIC),
    delta_AIC    = AIC - min(AIC),
    best_model   = (model_rank == min(model_rank[delta_AIC < 2]))
  ) %>%
  filter(best_model) %>%
  ungroup() %>%
  mutate(
    model_type = 
      case_when(
        model_type == "non_region"                   ~ "Main effect only",
        model_type == "add_region" & P_slope <  0.05 ~ "Main effect + region",
        model_type == "add_region" & P_slope >= 0.05 ~ "Region only",
        model_type == "int_region"                   ~ "Main effect * region"
      ) %>%
      factor(levels = c(
        "Main effect * region",
        "Main effect + region",
        "Main effect only",
        "Region only"
      )),
    variable = str_replace_all(variable, "_", " "),
    slope_sign  = ifelse(slope        > 0, "+", "-"),
    region_sign = ifelse(region_coeff > 0, "+", "-"),
    int_sign    = ifelse(int_coeff    > 0, "+", "-")
  ) %>%
  mutate_at(c("P_slope", "P_region", "P_int"),
    ~ case_when(
      .x < 0.001 ~ "***",
      .x < 0.010 ~ "**",
      .x < 0.050 ~ "*",
      .x < 0.100 ~ ".",
      TRUE       ~ " "
    )
  ) %>%
  mutate_if(is.character, ~ ifelse(is.na(.x), " ", .x)) %>%
  dplyr::select(
    model_type,  variable,
    slope_sign,  P_slope,
    region_sign, P_region,
    int_sign,    P_int
  ) %>%
  arrange(model_type)
  
# Remove variable names after first mention in table
univar_model_summary$model_type %<>% as.character()
for (pred in unique(univar_model_summary$model_type)) {
  to_remove <- which(univar_model_summary$model_type == pred)[-1]
  univar_model_summary$model_type[to_remove] <- " "
}

# No interaction models best-fitting, so remove those columns
univar_model_summary %<>% dplyr::select(-int_sign, -P_int)

# Print summary table
knitr::kable(univar_model_summary,
  caption = paste(
    "Summarised results of the best fitting separate simple linear",
    "regressions of log~10~[_S_~DS~] against environmental heterogeneity."
  ),
  col.names = c(
    "Model type",   "Heterogeneity predictor",
    "Slope",        " ",
    "SWAFR effect", " "
  ),
  align = "llclcl"
)
```

## 3.2. Multivariate models

```{r fit-multivariate-models, results="hide"}
data$QDS %<>% mutate(log10_QDS_richness = log10(QDS_richness))
data$HDS %<>% mutate(log10_HDS_richness = log10(HDS_richness))
data$DS  %<>% mutate(log10_DS_richness  = log10(DS_richness))

full_formula <- predictor_names[predictor_names != "PC1"] %>%
  {c(., paste(., "* region"))} %>%
  paste(collapse = " + ")

m_QDS_richness1 <- lm(glue("QDS_richness       ~ {full_formula}"), data$QDS)
m_QDS_richness  <- lm(glue("log10_QDS_richness ~ {full_formula}"), data$QDS)

m_HDS_richness1 <- lm(glue("HDS_richness       ~ {full_formula}"), data$HDS)
m_HDS_richness  <- lm(glue("log10_HDS_richness ~ {full_formula}"), data$HDS)

m_DS_richness1 <- lm(glue("DS_richness        ~ {full_formula}"),  data$DS)
m_DS_richness  <- lm(glue("log10_DS_richness  ~ {full_formula}"),  data$DS)

AIC(m_QDS_richness1, m_QDS_richness)
AIC(m_HDS_richness1, m_HDS_richness)
AIC(m_DS_richness1,  m_DS_richness)
# log10-transformed response always best supported

m_QDS_richness %<>% step(direction = "backward", trace = 0)
m_HDS_richness %<>% step(direction = "backward", trace = 0)
m_DS_richness  %<>% step(direction = "backward", trace = 0)
```

```{r reparamaterise-models}
# Reparameterise models to {*}:regionGCFR & {*}:regionSWAFR
# a.o.t. {*}*region, so that the figure of the effects actually represents
# each region, not the baseline (GCFR) and "relative SWAFR"
# (and that would cause inconsistencies too when their is no interaction with
# region term for a roughness variable).
reparameterise <- function(m) {
  response <- colnames(m$model)[[1]]
  dataset <- data %$% {
    if      (response == "log10_QDS_richness") QDS
    else if (response == "log10_HDS_richness") HDS
    else if (response == "log10_DS_richness")  DS
  }
  preds_w_interactions <- m %$%
    coefficients %>%
    names() %>%
    magrittr::extract(str_which(., ":regionSWAFR"))
  reparameterisation <- preds_w_interactions %>%
    str_remove(":regionSWAFR") %>%
    {glue("-{.}")} %>%
    paste(collapse = " ")
  update(m,
    formula = glue(". ~ . {reparameterisation}"),
    data    = dataset
  )
}
# Test:
#   a <- m_HDS_richness
#   b <- reparameterise(m_HDS_richness)
#   AIC(a, b) # same model! :)
m_QDS_richness %<>% reparameterise()
m_HDS_richness %<>% reparameterise()
m_DS_richness  %<>% reparameterise()
```

```{r summarise-models, results="hide"}
models <- list(
  QDS_richness = m_QDS_richness,
  HDS_richness = m_HDS_richness,
  DS_richness  = m_DS_richness
)
models_summary <- models %>%
  map_df(.id = "response", tidy, conf.int = TRUE) %>%
  dplyr::select(-std.error, -statistic) %>%
  filter(term != "(Intercept)")

models_R2 <- models %>%
  map_df(.id = "response", glance) %>%
  dplyr::select(response, adj.r.squared)

models_summary %<>% full_join(models_R2)

glance(m_QDS_richness)
glance(m_HDS_richness)
glance(m_DS_richness)

data$QDS$multivariate_residual <- m_QDS_richness$residuals
data$HDS$multivariate_residual <- m_HDS_richness$residuals
data$DS$multivariate_residual  <- m_DS_richness$residuals
```

```{r more-maps, eval=FALSE}
ggplot(data$QDS, aes(lon, lat, colour = multivariate_residual)) +
  geom_point(size = 3) +
  facet_grid(~region, scales = "free_x") +
  scale_colour_viridis_c()
ggplot(data$HDS, aes(lon, lat, colour = multivariate_residual)) +
  geom_point(size = 5) +
  facet_grid(~region, scales = "free_x") +
  scale_colour_viridis_c()
ggplot(data$DS, aes(lon, lat, colour = multivariate_residual)) +
  geom_point(size = 10) +
  facet_grid(~region, scales = "free_x") +
  scale_colour_viridis_c()
```

```{r plot-multivariate-models, fig.width=7, fig.height=6, fig.cap="..."}
models_R2adjs <- models_summary %>%
  group_by(response) %>%
  summarise(adj.r.squared = adj.r.squared %>%
    unique() %>%
    round(digits = 2)
  )
models_summary_for_plot <- models_summary %>%
  mutate(
    response = case_when(
      response == "QDS_richness" ~ "(a)~QDS~~(italic(R)[adj]^2=='0.20')",
      response == "HDS_richness" ~ "(b)~HDS~~(italic(R)[adj]^2=='0.21')",
      response == "DS_richness"  ~ "(c)~DS~~(italic(R)[adj]^2=='0.78')"
    ),
    region = 
      case_when(
        str_detect(term, "regionSWAFR") ~ "SWAFR", 
        str_detect(term, "regionGCFR")  ~ "GCFR",
        TRUE                            ~ "Main effect only"
      ) %>%
      factor(levels = c("Main effect only", "GCFR", "SWAFR")),
    term = term %>%
      str_replace_all("_", " ") %>%
      str_remove_all("regionSWAFR:") %>%
      str_remove_all("regionGCFR:") %>%
      str_replace_all("regionSWAFR", "SWAFR") %>%
      factor(levels = c(var_names, "SWAFR")),
    sig = ifelse(p.value < 0.05, "< 0.05", "NS")
  )
ggplot(models_summary_for_plot) +
  aes(
    term, estimate,
    fill = region, group = region, shape = region,
    alpha = sig
  ) +
  geom_hline(yintercept = 0, linetype = "dashed", colour = "grey75") +
  geom_errorbar(
    aes(ymin = conf.low, ymax = conf.high),
    position = position_dodge(width = 0.25),
    width = 0
  ) +
  geom_point(position = position_dodge(width = 0.25), size = 2) +
  labs(
    x = "Heterogeneity predictor",
    y = bquote(
      "Effect"~~
      "(log"["10"]*italic("S")*")"
    )
  ) +
  scale_fill_manual(values = c(NA, "black", "white")) +
  scale_shape_manual(values = c(4, 21, 21)) +
  scale_alpha_manual(values = c(1, 0.25)) +
  facet_wrap(~response, nrow = 3, scales = "free_y", labeller = label_parsed) +
  guides(
    fill = FALSE,
    shape = guide_legend(
      title = "Effect type",
      override.aes = list(fill = c(NA, "black", "white"))
    ),
    alpha = guide_legend(
      title = bquote(italic("P")["Effect"]),
      override.aes = list(alpha = c(1, 0.25), linetype = NA)
    )
  ) +
  theme(
    axis.text.x  = element_text(angle = 90, hjust = 1, vjust = 0.5),
    axis.text.y  = element_text(angle = 90, hjust = 0.5),
    strip.text.x = element_text(angle =  0, hjust = 0)
  )
#save.image(here("draft-02/manuscript_ver3/2019-09-03_saved-workspace.Rdata"))
```

```{r, eval=FALSE}
models_summary_for_plot %>%
  mutate(
    scale = c(0.25, 0.50, 1.00)[as.numeric(as.factor(response))],
    term_effect = paste(term, region)
  ) %>%
  ggplot() +
    aes(
      scale, estimate,
      fill = region, shape = region, group = term_effect
    ) +
    geom_hline(yintercept = 0, linetype = "dashed", colour = "grey75") +
    geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0) +
    geom_line() +
    geom_point() +
    labs(
      x = "Spatial scale",
      y = bquote(
        "Effect"~~
        "(log"["10"]*italic("S")*")"
      )
    ) +
    scale_fill_manual(values = c(NA, "black", "white")) +
    scale_shape_manual(values = c(4, 21, 21)) +
    scale_alpha_manual(values = c(1, 0.25)) +
    facet_wrap(~term, nrow = 2) +
    theme(
      axis.text.x  = element_text(angle = 90, hjust = 1, vjust = 0.5),
      axis.text.y  = element_text(angle = 90, hjust = 0.5),
      strip.text.x = element_text(angle =  0, hjust = 0)
    )
```

```{r, eval=FALSE}
data_all_scales <- data %$% rbind(
  QDS %>%
    rename(richness = log10_QDS_richness) %>%
    add_column(scale = "QDS") %>%
    dplyr::select(scale, region, Elevation:pH, richness),
  HDS %>%
    rename(richness = log10_HDS_richness) %>%
    add_column(scale = "HDS") %>%
    dplyr::select(scale, region, Elevation:pH, richness),
  DS %>%
    rename(richness = log10_DS_richness) %>%
    add_column(scale = "DS") %>%
    dplyr::select(scale, region, Elevation:pH, richness)
)
full_formula <- predictor_names[predictor_names != "PC1"] %>%
  {c(., paste(., "* region * scale"))} %>%
  paste(collapse = " + ")

m_all_scales <- lm(glue("richness ~ {full_formula}"), data_all_scales)
m_all_scales %<>% step()
preds_w_interactions <- m_all_scales %$%
  coefficients %>%
  names() %>%
  magrittr::extract(str_which(., ":(regionSWAFR|scale.?DS)"))
reparameterisation <- preds_w_interactions %>%
  str_remove(":(regionSWAFR|scale.?DS)") %>%
  unique() %>%
  {glue("-{.}")} %>%
  paste(collapse = " ")
m_all_scales %<>% update(
  formula = glue(". ~ . {reparameterisation}"),
  data    = data_all_scales
)
summary(m_all_scales)
m_all_scales %>%
  tidy(conf.int = TRUE) %>%
  dplyr::select(-std.error, -statistic) %>%
  filter(term != "(Intercept)") %>%
  mutate(
    region = 
      case_when(
        str_detect(term, "regionSWAFR") ~ "SWAFR", 
        str_detect(term, "regionGCFR")  ~ "GCFR",
        TRUE                            ~ "Main effect only"
      ) %>%
      factor(levels = c("Main effect only", "GCFR", "SWAFR")),
    scale =
      case_when(
        str_detect(term, "scaleQDS") ~ "QDS", 
        str_detect(term, "scaleHDS") ~ "HDS",
        str_detect(term, "scaleDS")  ~ "DS",
        TRUE                         ~ "Main effect only"
      ) %>%
      factor(levels = c("Main effect only", "QDS", "HDS", "DS")),
    term = term %>%
      str_replace_all("_", " ") %>%
      str_remove_all("(scale|region)(.?DS|(SWA|GC)FR):"),
    sig = ifelse(p.value < 0.05, "< 0.05", "NS")
  ) %>%
  filter(term %in% var_names) %>%
  mutate(term = factor(term, levels = c(var_names, "regionSWAFR", "scaleQDS", "scaleHDS"))) %>%
  ggplot() +
    aes(
      term, estimate,
      colour = scale, fill = region, shape = region,
      alpha = sig
    ) +
    geom_hline(yintercept = 0, linetype = "dashed", colour = "grey75") +
    geom_errorbar(
      aes(ymin = conf.low, ymax = conf.high),
      position = position_dodge(width = 0.25),
      width = 0
    ) +
    geom_point(position = position_dodge(width = 0.25), size = 2) +
    labs(
      x = "Heterogeneity predictor",
      y = bquote(
        "Effect"~~
        "(log"["10"]*italic("S")*")"
      )
    ) +
    scale_fill_manual(values = c(NA, "black", "white")) +
    scale_shape_manual(values = c(4, 21, 21)) +
    scale_alpha_manual(values = c(1, 0.25)) +
    guides(
      fill = FALSE,
      shape = guide_legend(
        title = "Effect type",
        override.aes = list(fill = c(NA, "black", "white"))
      ),
      alpha = guide_legend(
        title = bquote(italic("P")["Effect"]),
        override.aes = list(alpha = c(1, 0.25), linetype = NA)
      )
    ) +
    theme(
      axis.text.x  = element_text(angle = 90, hjust = 1, vjust = 0.5),
      axis.text.y  = element_text(angle = 90, hjust = 0.5),
      strip.text.x = element_text(angle =  0, hjust = 0)
    )
```
